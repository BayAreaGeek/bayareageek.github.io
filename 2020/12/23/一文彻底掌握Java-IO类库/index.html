<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>一文彻底掌握Java IO类库 | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java开发过程中经常会用到 Java IO 类库，本文将深入源码，带你彻底掌握 Java IO 类库。">
<meta property="og:type" content="article">
<meta property="og:title" content="一文彻底掌握Java IO类库">
<meta property="og:url" content="http://example.com/2020/12/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java-IO%E7%B1%BB%E5%BA%93/index.html">
<meta property="og:site_name">
<meta property="og:description" content="Java开发过程中经常会用到 Java IO 类库，本文将深入源码，带你彻底掌握 Java IO 类库。">
<meta property="og:locale">
<meta property="og:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java%20IO%E7%B1%BB%E5%BA%93%2FJava%20IO%20%E7%B1%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2020-12-23T14:57:44.000Z">
<meta property="article:modified_time" content="2024-02-18T13:17:51.584Z">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="IO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java%20IO%E7%B1%BB%E5%BA%93%2FJava%20IO%20%E7%B1%BB%E5%9B%BE.png">
  
    <link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-一文彻底掌握Java-IO类库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java-IO%E7%B1%BB%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2020-12-23T14:57:44.000Z" itemprop="datePublished">2020-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      一文彻底掌握Java IO类库
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java开发过程中经常会用到 Java IO 类库，本文将深入源码，带你彻底掌握 Java IO 类库。</p>
<span id="more"></span>

<h2 id="Java-IO类图框架"><a href="#Java-IO类图框架" class="headerlink" title="Java IO类图框架"></a>Java IO类图框架</h2><p>Java IO 类库可以大体划分为字节流和字符流两大类，再根据输入和输出两种情况，可以再分为四小类。所以<a target="_blank" rel="noopener" href="https://bubcoaxnbl.feishu.cn/mindnotes/bmncnZAhJYFx5oWnuECGAXR2Fhd">大致框架图</a>如下所示：<br><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java%20IO%E7%B1%BB%E5%BA%93%2FJava%20IO%20%E7%B1%BB%E5%9B%BE.png" alt="Java IO 类图.png"></p>
<p>如上图，Java 类图并不繁多，而且分类和命名都非常清晰。其中需要重点掌握的类已经加粗展示在图里。</p>
<p>下边我们逐类逐个展开分析整个类库。</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>顾名思义，字节流相关类是处理字节类型数据的，而且都是以『Stream』为后缀的类。根据输入输出类型，可以划分为 InputStream 或 OutputStream 的两大类的实现类。</p>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>先看看内部方法：</p>
<pre><code class="java">public abstract class InputStream implements Closeable &#123;
    public abstract int read() throws IOException;
    public int read(byte b[]) throws IOException &#123;/***/&#125;
    public int read(byte b[], int off, int len) throws IOException &#123;/***/&#125;
    public long skip(long n) throws IOException &#123;/***/&#125;
    public int available() throws IOException &#123;/***/&#125;
    public void close() throws IOException &#123;/***/&#125;
    public synchronized void mark(int readlimit) &#123;/***/&#125;
    public synchronized void reset() throws IOException &#123;/***/&#125;
    public boolean markSupported() &#123;/***/&#125;
</code></pre>
<p>InputStream 实现了 Closeable 接口，并且内部只有一个抽象方法 read， 所有实现类都强制要求实现该方法。其他方法提供了非常扼要的默认实现，实现类可以酌情覆盖实现。</p>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p>在<a target="_blank" rel="noopener" href="https://blog.duval.top/2020/12/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/">《深入理解Java文件输入输出流和文件描述符》</a>我们已经深入探讨过该类。</p>
<p>简单来说，FileInputStream 内部通过文件描述符 FileDescriptor 和系统文件关联起来，并通过 native 方法调用系统 API 读写文件。</p>
<h4 id="FilterInputStream"><a href="#FilterInputStream" class="headerlink" title="FilterInputStream"></a>FilterInputStream</h4><p>FilterInputStream 采用装饰器模式，内部包装了一个 InputStream 对象，并且继承了 InputStream 并覆写全部方法，但方法内容都是单纯地调用内部包装的 InputStream 对象。如下：</p>
<pre><code class="java">public
class FilterInputStream extends InputStream &#123;
    protected volatile InputStream in;

    protected FilterInputStream(InputStream in) &#123;
        this.in = in;
    &#125;

    public int read() throws IOException &#123;
        return in.read();
    &#125;

    public int read(byte b[]) throws IOException &#123;
        return read(b, 0, b.length);
    &#125;

    public int read(byte b[], int off, int len) throws IOException &#123;
        return in.read(b, off, len);
    &#125;

    public long skip(long n) throws IOException &#123;
        return in.skip(n);
    &#125;

    public int available() throws IOException &#123;
        return in.available();
    &#125;

    public void close() throws IOException &#123;
        in.close();
    &#125;


    public synchronized void mark(int readlimit) &#123;
        in.mark(readlimit);
    &#125;

    public synchronized void reset() throws IOException &#123;
        in.reset();
    &#125;

    public boolean markSupported() &#123;
        return in.markSupported();
    &#125;
&#125;
</code></pre>
<p>所以正如其名，FilterInputStream 就像是内部 InputStream 对象的一个过滤器一般，所有方法调用都需要经过一层包装方法的『过滤』才能到达内部对象。FilterInputStream 并没有逻辑实现，具体实现需要子类覆写相关方法实现。</p>
<p>比较有意思的实现有以下几个：</p>
<ul>
<li><strong>BufferedInputStream</strong><blockquote>
<p>BufferedInputStream 内部使用一个 buf 字节数组进行缓冲，覆写了 FilterInputStream 的全部方法实现一个带缓冲区的字节流类。在进行磁盘或网络IO时，原始的InputStream对数据读取的过程都是一个字节一个字节操作的，而BufferedInputStream在其内部提供了一个buffer，在读数据时，会一次读取一大块数据到buffer中，这样比单字节的操作效率要高的多，特别是进程磁盘IO和对大量数据进行读写的时候,能提升IO性能。</p>
</blockquote>
</li>
<li><strong>PushbackInputStream</strong><blockquote>
<p>PushbackInputStream 内部同样使用一个 buf 字节数组对已读数据进行缓存，然后可以通过 unread 方法将已读的数据重新放回 buf 数组，从而实现了一个支持 push back 的字节流类。</p>
</blockquote>
</li>
<li><strong>DataInputStream</strong><blockquote>
<p>DataInputStream 提供了许多可以读取 Java 基本类型的方法。</p>
</blockquote>
</li>
</ul>
<h4 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h4><p>ByteArrayInputStream 支持从 byte 数组读取数据，通过构造函数可以指定该 byte 数组：</p>
<pre><code class="java">    protected byte buf[];

    protected int pos;

    protected int mark = 0;

    protected int count;

    public ByteArrayInputStream(byte buf[]) &#123;
        this.buf = buf;
        this.pos = 0;
        this.count = buf.length;
    &#125;

    public ByteArrayInputStream(byte buf[], int offset, int length) &#123;
        this.buf = buf;
        this.pos = offset;
        this.count = Math.min(offset + length, buf.length);
        this.mark = offset;
    &#125;
</code></pre>
<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><p>ObjectInputStream 与 DataInputStream 类似也支持 Java 基本类型的读取，此外还支持反序列化读取对象。它常常与 ObjectOutputStream 搭配使用。因此，ObjectOutputStream 实现将基本类型或者对象序列化并输出到 IO 字节流或者设备上，而 ObjectInputStream 从 IO 字节流或者设备上反序列化读取基本类型或者对象。</p>
<p>比如，从文件中读取一个 person 对象。</p>
<pre><code class="java">ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;data.txt&quot;));
Person person = (MyClass) input.readObject(); 
input.close();
</code></pre>
<p>这里要求 Person 一定要实现 java.io.Serializable 接口。</p>
<h4 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="PipedInputStream"></a>PipedInputStream</h4><p>PipedInputStream 通常和 PipedOutputStream 搭配使用，实现了一个承载字节流的管道类。PipedOutputStream 的输出会自动调用 PipedInputStream 的 receive 方法作为输入。PipedInputStream 提供了以下几个特殊方法：</p>
<pre><code class="java">// 连接 PipedOutputStream 对象，形成管道
public void connect(PipedOutputStream src) throws IOException;
// 接收一个字节
protected synchronized void receive(int b) throws IOException;
// 接收一个字节数组
synchronized void receive(byte b[], int off, int len)  throws IOException;
</code></pre>
<p>注意到其 read 方法和 receive 都是同步方法，read 方法在没有数据的时候会发生阻塞，而 receive 方法在缓冲数组没有剩余空间的时候也会发生阻塞：</p>
<pre><code class="java">public synchronized int read()  throws IOException &#123;
        if (!connected) &#123;
            throw new IOException(&quot;Pipe not connected&quot;);
        &#125; else if (closedByReader) &#123;
            throw new IOException(&quot;Pipe closed&quot;);
        &#125; else if (writeSide != null &amp;&amp; !writeSide.isAlive()
                   &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) &#123;
            throw new IOException(&quot;Write end dead&quot;);
        &#125;

        readSide = Thread.currentThread();
        int trials = 2;
        while (in &lt; 0) &#123;
            // in小于0表示缓冲数组为空，处于无数据状态
            if (closedByWriter) &#123;
                /* closed by writer, return EOF */
                return -1;
            &#125;
            if ((writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)) &#123;
                throw new IOException(&quot;Pipe broken&quot;);
            &#125;
            /* might be a writer waiting */
            notifyAll();
            try &#123;
                // 阻塞等待
                wait(1000);
            &#125; catch (InterruptedException ex) &#123;
                throw new java.io.InterruptedIOException();
            &#125;
        &#125;
        int ret = buffer[out++] &amp; 0xFF;
        if (out &gt;= buffer.length) &#123;
            out = 0;
        &#125;
        if (in == out) &#123;
            /* now empty */
            in = -1;
        &#125;

        return ret;
    &#125;


protected synchronized void receive(int b) throws IOException &#123;
        checkStateForReceive();
        writeSide = Thread.currentThread();
        if (in == out)
            // 当in等于out，意味着缓冲数组已满，阻塞等待空间释放
            awaitSpace();
        if (in &lt; 0) &#123;
            in = 0;
            out = 0;
        &#125;
        buffer[in++] = (byte)(b &amp; 0xFF);
        if (in &gt;= buffer.length) &#123;
            in = 0;
        &#125;
    &#125;
</code></pre>
<h4 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h4><p>SequenceInputStream 支持将多个 InputStream 组合起来，并按照顺序进行读取。</p>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>OutputStream 与 InputStream 相对应，实现上存在很多相似之处。先看看内部方法：</p>
<pre><code class="java">public abstract class OutputStream implements Closeable, Flushable &#123;
    public abstract void write(int b) throws IOException;
    public void write(byte b[]) throws IOException &#123;/***/&#125;
    public void write(byte b[], int off, int len) throws IOException &#123;/***/&#125;
    public void flush() throws IOException &#123;/***/&#125;
    public void close() throws IOException &#123;/***/&#125;
&#125;
</code></pre>
<p>OutputStream 实现了 Closeable 接口和 Flushable 方法，同样有一个抽象的 write 方法需要实现。其他方法提供框架性代码，也需要实现类覆写相关方法，提供更多的自定义功能。</p>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>实现上与 FileInputStream 类似，提供对文件写入字节流的功能。</p>
<h4 id="FilterOutputStream"><a href="#FilterOutputStream" class="headerlink" title="FilterOutputStream"></a>FilterOutputStream</h4><p>与 FilterInputStream 类似，对 OutputStream 对象进行包装，并继承了 OutputStream 并覆写全部方法，方法内容都是简单地调用内部的 OutputStream 对象。</p>
<p>同样的也有几个子类实现：</p>
<ul>
<li><strong>BufferedOutputStream</strong>：带缓冲区的字节流输出类，与 BufferedInputStream 对应；</li>
<li><strong>DataOutputStream</strong>：提供写 Java 基本类型相关方法的字节流类，与 DataInputStream 对应；</li>
<li><strong>PrintStream</strong>：与 DataOutputStream 有些类似，不过它提供了更加丰富的写出方法，并且支持换行输出。</li>
</ul>
<h4 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h4><p>与 ByteArrayInputStream 相反，ByteArrayOutputStream 实现输出到内部的缓存字节数组 buf 中。特有的方法有：</p>
<pre><code class="java">/** 将该 Stream 输出为 byte 数组**/
public synchronized byte toByteArray()[] &#123;
    return Arrays.copyOf(buf, count);
&#125;
/** 将该 Stream 输出到另一个 Stream 上**/
public synchronized void writeTo(OutputStream out) throws IOException &#123;
    out.write(buf, 0, count);
&#125;
</code></pre>
<h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><p>与 ObjectInputStream 对应，ObjectOutputStream 实现将 Java 基本类型数据或者 Java 对象序列化后写入输出字节流中。</p>
<h4 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="PipedOutputStream"></a>PipedOutputStream</h4><p>与 PipedInputStream 搭配使用，PipedOutputStream 会输出字节流到管道另一端的 PipedInputStream。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字节流处理的是 byte 数组，而字符流处理的是 char 数组。而且字符流相关的类都以 Reader 或者 Writer 为后缀。</p>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>先看看内部方法：</p>
<pre><code class="java">public abstract class Reader implements Readable, Closeable &#123;
    public int read(java.nio.CharBuffer target) throws IOException;
    public int read() throws IOException;
    public int read(char cbuf[]) throws IOException;
    abstract public int read(char cbuf[], int off, int len) throws IOException;
    public long skip(long n) throws IOException;
    public boolean ready() throws IOException;
    public boolean markSupported();
    public void mark(int readAheadLimit) throws IOException;
    public void reset() throws IOException;
    abstract public void close() throws IOException;
&#125;
</code></pre>
<p>内部方法与 InputStream 非常相似，同样实现类需要实现 read 方法。</p>
<h4 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h4><p>带缓冲区的 Reader 实现。</p>
<h4 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h4><p>从字符数组读取数据的 Reader 实现。</p>
<h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p>InputStreamReader 是一个包装类，内部对象是 StreamDecoder。StreamDecoder 支持从 InputStream 中读取字符。</p>
<pre><code class="java">public class InputStreamReader extends Reader &#123;

    private final StreamDecoder sd;

    /**
     * Creates an InputStreamReader that uses the default charset.
     *
     * @param  in   An InputStream
     */
    public InputStreamReader(InputStream in) &#123;
        super(in);
        try &#123;
            sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## check lock object
        &#125; catch (UnsupportedEncodingException e) &#123;
            // The default encoding should always be available
            throw new Error(e);
        &#125;
    &#125;
    // ...
&#125;
</code></pre>
<ul>
<li><p><strong>FileReader</strong>：InputStreamReader 的实现，入参是一个 FileInputStream 对象</p>
<pre><code class="java">  public FileReader(String fileName) throws FileNotFoundException &#123;
      super(new FileInputStream(fileName));
  &#125;
</code></pre>
</li>
</ul>
<h4 id="FilterReader"><a href="#FilterReader" class="headerlink" title="FilterReader"></a>FilterReader</h4><p>FilterReader 与上文的 FilterInputStream 类似，也是一个包装类。它内部包含一个 Reader 对象，并且继承自 Reader 并覆写所有方法，而方法内容都是简单调用内部 Reader 对象。</p>
<ul>
<li><strong>PushbackReader</strong>：FilterReader 的实现类，内部使用一个 buf 字符数组对已读数据进行缓存，然后可以通过 unread 方法将已读的数据重新放回 buf 数组，从而实现了一个支持 push back 的字符流类。</li>
</ul>
<h4 id="PipedReader"><a href="#PipedReader" class="headerlink" title="PipedReader"></a>PipedReader</h4><p>与 PipedInputStream 类似</p>
<h4 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h4><p>与 CharArrayReader 类似</p>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><h4 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h4><p>带缓冲区的 Writer 实现。</p>
<h4 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h4><p>与 CharArrayReader 相反，CharArrayWriter 将数据写入内部字符数组中。其特有方法有：</p>
<pre><code class="java">public char toCharArray()[] &#123;
    synchronized (lock) &#123;
        return Arrays.copyOf(buf, count);
    &#125;
&#125;

public void writeTo(Writer out) throws IOException &#123;
    synchronized (lock) &#123;
        out.write(buf, 0, count);
    &#125;
&#125;
</code></pre>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>与 InputStreamReader 相对，OutputStreamWriter 也是一个包装类，内部对象是 StreamEncoder。StreamEncoder 支持将字符输出到 OutputStream 中。</p>
<ul>
<li><p><strong>FileWriter</strong>OutputStreamWriter 的实现，入参是一个 FileOutputStream 对象</p>
<pre><code class="java">  public FileWriter(String fileName) throws IOException &#123;
      super(new FileOutputStream(fileName));
  &#125;
</code></pre>
</li>
</ul>
<h4 id="FilterWriter"><a href="#FilterWriter" class="headerlink" title="FilterWriter"></a>FilterWriter</h4><p>FilterWriter 的是一个包装类，内部包含一个 Writer 对象，同时也继承了 Writer，并覆写了部分方法。这个类在 JDK 里没有找到相关实现子类。</p>
<h4 id="PipedWriter"><a href="#PipedWriter" class="headerlink" title="PipedWriter"></a>PipedWriter</h4><p>与 PipedReader PipedWriter 会输出字符流到管道另一端的 PipedWriter。</p>
<h4 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h4><p>类似 PrintStream，提供了丰富的写出方法，并且支持换行输出。这里发现其并没有实现 FilterWriter，这点与 PrintStream 的继承结构并不吻合。个人觉得这点不是很好，但是也无伤大雅。</p>
<h4 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h4><p>将字符流输出到内部的 StringBuffer 上，同时可以通过 toString 方法获取内部的字符串缓存：</p>
<pre><code class="java">public String toString() &#123;
    return buf.toString();
&#125;
</code></pre>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>FileInputStream（文件字符流）或 FileReader（文件字节流）来读文件都只能够实现从文件开始顺序读取到文件结束。</p>
<p>而 RandomAccessFile 可以实现随机读写，用来只读取文件中的一部分：</p>
<pre><code class="java">public class RandAccessDemo &#123;
    public static String randomAccessFileRead() throws IOException &#123;
        // 创建一个RandomAccessFile对象
        RandomAccessFile file = new RandomAccessFile( &quot;data.txt&quot;, &quot;rw&quot;);
        // 通过seek方法来移动读写位置的指针
        file.seek(10);
        // 获取当前指针
        long pointerBegin = file.getFilePointer();
        // 从当前指针开始读
        byte[] contents = new byte[1024];
        file.read( contents);
        long pointerEnd = file.getFilePointer();
        System. out.println( &quot;pointerBegin:&quot; + pointerBegin + &quot;\n&quot; + &quot;pointerEnd:&quot; + pointerEnd + &quot;\n&quot; + new String(contents));
        String dataStr = new String(contents);
        file.close();
        return dataStr;
    &#125;

    public static void randomAccessFileWrite(String dataStr) throws IOException &#123;
        // 创建一个RandomAccessFile对象
        RandomAccessFile file = new RandomAccessFile(&quot;data.txt&quot;, &quot;rw&quot;);
        // 通过seek方法来移动读写位置的指针
        file.seek(10);
        // 获取当前指针
        long pointerBegin = file.getFilePointer();
        // 从当前指针位置开始写
        file.write(dataStr.getBytes());
        long pointerEnd = file.getFilePointer();
        System.out.println(&quot;pointerBegin:&quot; + pointerBegin + &quot;\n&quot; + &quot;pointerEnd:&quot; + pointerEnd + &quot;\n&quot;);
        file.close();
    &#125;
&#125;
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-chen-hao/p/11083740.html#_label2_5">高级Java工程师必备 —– 深入分析 Java IO （三）</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java-IO%E7%B1%BB%E5%BA%93/" data-id="cltbach2b00183kr1d3ecdykl" data-title="一文彻底掌握Java IO类库" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/28/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1-Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          一文彻底掌握 Java 类加载机制
        
      </div>
    </a>
  
  
    <a href="/2020/12/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">深入理解Java文件输入输出流和文件描述符</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS%E5%8E%9F%E7%90%86/" rel="tag">CAS原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" rel="tag">代码整洁之道</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" rel="tag">垃圾回收器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" rel="tag">垃圾收集器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" rel="tag">性能分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" rel="tag">文件描述符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/" rel="tag">生产问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="tag">类加载机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" rel="tag">输入输出流</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CAS%E5%8E%9F%E7%90%86/" style="font-size: 10px;">CAS原理</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JVM/" style="font-size: 18.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/NIO/" style="font-size: 11.67px;">NIO</a> <a href="/tags/Netty/" style="font-size: 13.33px;">Netty</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Spring/" style="font-size: 16.67px;">Spring</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" style="font-size: 10px;">代码整洁之道</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" style="font-size: 13.33px;">垃圾回收器</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" style="font-size: 10px;">垃圾收集器</a> <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" style="font-size: 10px;">性能分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" style="font-size: 10px;">文件描述符</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 20px;">源码分析</a> <a href="/tags/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/" style="font-size: 13.33px;">生产问题</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">类加载机制</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a> <a href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" style="font-size: 10px;">输入输出流</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-6-ZGC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">Java 虚拟机原理 (六) ZGC 垃圾收集器</a>
          </li>
        
          <li>
            <a href="/2021/02/09/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-3-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%B7%E6%81%A9%E6%B3%95%E5%88%99/">生产问题(3) 应用开发过程中的海恩法则</a>
          </li>
        
          <li>
            <a href="/2021/02/07/%E6%B7%B1%E5%85%A5-MySQL-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">深入 MySQL (六) 常见问题汇总</a>
          </li>
        
          <li>
            <a href="/2021/02/06/%E6%B7%B1%E5%85%A5-MySQL-5-%E9%94%81/">深入 MySQL (五) 锁</a>
          </li>
        
          <li>
            <a href="/2021/02/05/%E6%B7%B1%E5%85%A5-MySQL-4-%E7%B4%A2%E5%BC%95/">深入 MySQL (四) 索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 <br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>