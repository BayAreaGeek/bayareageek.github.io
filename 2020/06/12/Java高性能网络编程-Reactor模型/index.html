<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java高性能网络编程--Reactor模型 | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Reactor模型是基于事件驱动的模型，是高性能网络编程中非常重要概念，常用于解决多核服务器下的如何处理海量I&#x2F;O问题。Java中大名鼎鼎的Netty网络编程框架的线程模型正是基于Reactor模型。 本文主要基于Doug Lea的文章Scalable IO in Java来介绍下Reactor模型。本文所有内容均基于前人资料总结而成，如有侵权必删。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高性能网络编程--Reactor模型">
<meta property="og:url" content="http://example.com/2020/06/12/Java%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Reactor%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name">
<meta property="og:description" content="Reactor模型是基于事件驱动的模型，是高性能网络编程中非常重要概念，常用于解决多核服务器下的如何处理海量I&#x2F;O问题。Java中大名鼎鼎的Netty网络编程框架的线程模型正是基于Reactor模型。 本文主要基于Doug Lea的文章Scalable IO in Java来介绍下Reactor模型。本文所有内容均基于前人资料总结而成，如有侵权必删。">
<meta property="og:locale">
<meta property="og:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B--Reactor%E6%A8%A1%E5%9E%8B%2F%E5%8D%95%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%9E%8B.jpg">
<meta property="og:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B--Reactor%E6%A8%A1%E5%9E%8B%2F%E5%A4%9A%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%9E%8B.jpg">
<meta property="og:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B--Reactor%E6%A8%A1%E5%9E%8B%2F%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg">
<meta property="article:published_time" content="2020-06-12T06:48:28.000Z">
<meta property="article:modified_time" content="2024-02-18T13:17:51.574Z">
<meta property="article:tag" content="NIO">
<meta property="article:tag" content="Reactor">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B--Reactor%E6%A8%A1%E5%9E%8B%2F%E5%8D%95%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%9E%8B.jpg">
  
    <link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java高性能网络编程-Reactor模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/12/Java%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Reactor%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2020-06-12T06:48:28.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java高性能网络编程--Reactor模型
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Reactor模型是基于事件驱动的模型，是高性能网络编程中非常重要概念，常用于解决多核服务器下的如何处理海量I&#x2F;O问题。Java中大名鼎鼎的Netty网络编程框架的线程模型正是基于Reactor模型。</p>
<p>本文主要基于Doug Lea的文章<a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a>来介绍下Reactor模型。<br>本文所有内容均基于前人资料总结而成，如有侵权必删。</p>
<span id="more"></span>

<h2 id="传统网络编程"><a href="#传统网络编程" class="headerlink" title="传统网络编程"></a>传统网络编程</h2><p>初学Java网络编程的时候，我们学过使用ServerSocket以及Socket来编码客户端与服务端的网络通讯程序。常见的服务端逻辑如下：</p>
<pre><code class="java">class Server implements Runnable &#123;
    public void run() &#123;
        try &#123;
            ServerSocket ss = new ServerSocket(PORT);
            while (!Thread.interrupted())
                new Thread(new Handler(ss.accept())).start();
            // or, single-threaded, or a thread pool
        &#125; catch (IOException ex) &#123; /* ... */ &#125;
    &#125;

    static class Handler implements Runnable &#123;
        final Socket socket;

        Handler(Socket s) &#123;
            socket = s;
        &#125;

        public void run() &#123;
            try &#123;
                byte[] input = new byte[MAX_INPUT];
                socket.getInputStream().read(input);
                byte[] output = process(input);
                socket.getOutputStream().write(output);
            &#125; catch (IOException ex) &#123; /* ... */ &#125;
        &#125;

        private byte[] process(byte[] cmd) &#123; /* ... */ &#125;
    &#125;
&#125;
</code></pre>
<p>上述样例代码是一个典型的TPC（Thread Per Connection)模式，这种模式有几个显而易见的问题：</p>
<ul>
<li>1.所有的I&#x2F;O操作都是阻塞的，包括accept、read、write等操作都会阻塞所在线程；</li>
<li>2.每个连接都会新建一个线程，连接结束后线程即被销毁，频繁创建线程带来较高的性能损耗；</li>
<li>3.I&#x2F;O线程和业务process线程耦合；</li>
<li>4.服务端采用单线程accept客户端的请求，海量I&#x2F;O下存在性能瓶颈。</li>
</ul>
<p>因此，这种TPC的网络模式只适合并发请求量较小的业务情景。</p>
<p>为了解决以上的问题，于是有了Reactor模型。</p>
<h2 id="单线程版本"><a href="#单线程版本" class="headerlink" title="单线程版本"></a>单线程版本</h2><p>先来看看最简单的单线程版本Reactor模型。如下图所示：</p>
<p><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B--Reactor%E6%A8%A1%E5%9E%8B%2F%E5%8D%95%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%9E%8B.jpg" alt="单线程Reactor模型.jpg"></p>
<p>配图是Doug Lea在他的文章中的图。从图里可以看到:</p>
<ul>
<li>Reactor对象负责监听事件，并将事件委派给各个I&#x2F;O方法执行；</li>
<li>Reactor线程收到accept事件后，便交给acceptor实例进行处理（注意acceptor实例属于Reactor线程）；</li>
<li>acceptor处理完accept事件后，会将该channel重新注册会Reactor线程中；</li>
<li>Reactor线程中继续监听这些channel的其他I&#x2F;O事件，并通过dispatch方法分别处理read、decode、compute、encode、send等I&#x2F;O事件。</li>
</ul>
<p>值得注意的是，这张图比较容易混淆的地方是Acceptor并不是一个单独的线程，而是Reactor线程内部的一个实例；且以上所有步骤都是在同一个Reactor线程内完成的。</p>
<p>因为只有一个线程，所以这种单线程的Reactor模型，并没有充分利用多核服务器的CPU资源，性能上甚至不如上边提到的TPC。</p>
<p>Java一般基于NIO的来实现Reactor模型，样例如下：</p>
<pre><code class="java">class Reactor implements Runnable
&#123;
    final Selector selector;
    final ServerSocketChannel serverSocket;

    Reactor(int port) throws IOException
    &#123; //Reactor初始化
        selector = Selector.open();
        serverSocket = ServerSocketChannel.open();
        serverSocket.socket().bind(new InetSocketAddress(port));
        //非阻塞
        serverSocket.configureBlocking(false);

        //分步处理,第一步,接收accept事件
        SelectionKey sk =
                serverSocket.register(selector, SelectionKey.OP_ACCEPT);
        //附加一个Acceptor实例
        sk.attach(new Acceptor());
    &#125;

    public void run()
    &#123;
        try
        &#123;
            while (!Thread.interrupted())
            &#123;
                selector.select();
                Set selected = selector.selectedKeys();
                Iterator it = selected.iterator();
                while (it.hasNext())
                &#123;
                    //Reactor负责dispatch收到的事件
                    dispatch((SelectionKey) (it.next()));
                &#125;
                selected.clear();
            &#125;
        &#125; catch (IOException ex)
        &#123; /* ... */ &#125;
    &#125;

    void dispatch(SelectionKey k)
    &#123;
        Runnable r = (Runnable) (k.attachment());
        //调用之前注册的callback对象
        if (r != null)
        &#123;
            r.run();
        &#125;
    &#125;

    // inner class
    class Acceptor implements Runnable
    &#123;
        public void run()
        &#123;
            try
            &#123;
                SocketChannel channel = serverSocket.accept();
                if (channel != null)
                    new Handler(selector, channel);
            &#125; catch (IOException ex)
            &#123; /* ... */ &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">

class Handler implements Runnable
&#123;
    final SocketChannel channel;
    final SelectionKey sk;
    ByteBuffer input = ByteBuffer.allocate(SystemConfig.INPUT_SIZE);
    ByteBuffer output = ByteBuffer.allocate(SystemConfig.SEND_SIZE);
    static final int READING = 0, SENDING = 1;
    int state = READING;

    Handler(Selector selector, SocketChannel c) throws IOException
    &#123;
        channel = c;
        c.configureBlocking(false);
        // 一般来说先注册读时间
        sk = channel.register(selector, 0);
        sk.attach(this);
        sk.interestOps(SelectionKey.OP_READ);
        selector.wakeup();
    &#125;

    boolean inputIsComplete()
    &#123;
        /* ... */
        return false;
    &#125;

    boolean outputIsComplete()
    &#123;

        /* ... */
        return false;
    &#125;

    void process()
    &#123;
        /* ... */
        return;
    &#125;

    public void run()
    &#123;
        try
        &#123;
            if (state == READING)
            &#123;
                read();
            &#125;
            else if (state == SENDING)
            &#123;
                send();
            &#125;
        &#125; catch (IOException ex)
        &#123; /* ... */ &#125;
    &#125;

    void read() throws IOException
    &#123;
        channel.read(input);
        if (inputIsComplete())
        &#123;
            // 进行其他业务处理
            process();
            state = SENDING;
            // 一般来说读完数据之后，重新注册写实践到Selector中
            sk.interestOps(SelectionKey.OP_WRITE);
        &#125;
    &#125;

    void send() throws IOException
    &#123;
        channel.write(output);

        //write事件结束后, 关闭select key
        if (outputIsComplete())
        &#123;
            sk.cancel();
        &#125;
    &#125;
&#125;
</code></pre>
<p>如上实现，Acceptor只是Reactor线程内部实例，相当于一个特殊的Handler。</p>
<h2 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h2><p>单线程版本的主要问题之一是：I&#x2F;O处理逻辑与Reactor耦合共用了同一个线程。于是，将I&#x2F;O处理逻辑剥离出来，交由单独的线程池来运行。于是有如下设计：</p>
<p><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B--Reactor%E6%A8%A1%E5%9E%8B%2F%E5%A4%9A%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%9E%8B.jpg" alt="多线程Reactor模型.jpg"></p>
<p>实现上只需要变更Handler的代码，由一个全局的线程池来执行任务即可：</p>
<pre><code class="java">class Handler implements Runnable &#123;
    // 全局公用的线程池
    static PooledExecutor pool = new PooledExecutor(...);
    static final int PROCESSING = 3;
    // ...
    synchronized void read() &#123; // ...
        socket.read(input);
        if (inputIsComplete()) &#123;
            state = PROCESSING;
            pool.execute(new Processer());
        &#125;
    &#125;
    synchronized void processAndHandOff() &#123;
        process();
        state = SENDING; // or rebind attachment
        sk.interest(SelectionKey.OP_WRITE);
    &#125;
    class Processer implements Runnable &#123;
        public void run() &#123; processAndHandOff(); &#125;
    &#125;
&#125;
</code></pre>
<p>该版本存在问题是：acceptor与Reactor共用一个线程，如果有海量的请求或者连接时候需要身份认证等耗时操作，会阻塞Reactor线程，影响了Reactor线程监控I&#x2F;O事件而成为性能瓶颈。</p>
<h2 id="主从Reator多线程版本"><a href="#主从Reator多线程版本" class="headerlink" title="主从Reator多线程版本"></a>主从Reator多线程版本</h2><p>为了解决以上问题，多Reactor多线程版本，引入多个Reactor，部分Reactor线程专门负责处理请求事件，以应对海量的请求或者耗时的连接操作；而其他的Reactor线程负责监听其他I&#x2F;O事件。于是有如下设计：</p>
<p><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B--Reactor%E6%A8%A1%E5%9E%8B%2F%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="多Reactor多线程模型.jpg"></p>
<p>这个版本有如下特点：</p>
<ul>
<li>单独的mainReactor线程来监听accept事件；</li>
<li>单独的subReactor线程来监听其他I&#x2F;O事件；</li>
<li>使用单独的线程池来处理业务。</li>
<li>实际生产中常用线程池来运行mainReactor和subReactor</li>
</ul>
<p><strong>现在许多高性能的网络应用或中间件都是采用这种主从多线程版本。</strong></p>
<h2 id="Reactor模型在Netty中的应用"><a href="#Reactor模型在Netty中的应用" class="headerlink" title="Reactor模型在Netty中的应用"></a>Reactor模型在Netty中的应用</h2><p>Netty的服务端在初始化ServerBootstrap的时候可以指定parentGroup和childGroup两个线程池。这两个线程池正好对应承载mainReactor和subReactor的两个线程池。</p>
<pre><code class="java">// io.netty.bootstrap.ServerBootstrap
@Override
public ServerBootstrap group(EventLoopGroup group) &#123;
    return group(group, group);
&#125;

/**
    * Set the &#123;@link EventLoopGroup&#125; for the parent (acceptor) and the child (client). These
    * &#123;@link EventLoopGroup&#125;&#39;s are used to handle all the events and IO for &#123;@link ServerChannel&#125; and
    * &#123;@link Channel&#125;&#39;s.
    */
public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123;
    super.group(parentGroup);
    if (childGroup == null) &#123;
        throw new NullPointerException(&quot;childGroup&quot;);
    &#125;
    if (this.childGroup != null) &#123;
        throw new IllegalStateException(&quot;childGroup set already&quot;);
    &#125;
    this.childGroup = childGroup;
    return this;
&#125;
</code></pre>
<p>因此通过控制parentGroup和childGroup的线程池大小，可以实现以上各个版本的reactor模型。</p>
<ul>
<li>单线程版本：</li>
</ul>
<pre><code class="java">NioEventLoopGroup group = new NioEventLoopGroup(1);
        ServerBootstrap bootstrap = new ServerBootstrap();
        bootstrap.group(group)
                .channel(NioServerSocketChannel.class)
                .channel(NioServerSocketChannel.class)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_BACKLOG, 1024)
                .childHandler(new ServerHandlerInitializer());
</code></pre>
<ul>
<li>多线程版本:</li>
</ul>
<pre><code class="java">NioEventLoopGroup eventGroup = new NioEventLoopGroup();
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(eventGroup)
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.TCP_NODELAY, true)
        .option(ChannelOption.SO_BACKLOG, 1024)
        .childHandler(new ServerHandlerInitializer());
</code></pre>
<ul>
<li>主从多线程版本</li>
</ul>
<pre><code class="java">NioEventLoopGroup bossGroup = new NioEventLoopGroup();
NioEventLoopGroup workerGroup = new NioEventLoopGroup();
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(bossGroup,workerGroup)
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.TCP_NODELAY, true)
        .option(ChannelOption.SO_BACKLOG, 1024)
        .childHandler(new ServerHandlerInitializer());
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a>   Doug Lea大牛写的文章，简明扼要，网上的资料基本都是从这文章衍生出来的。</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/9833847.html">Reactor模式</a> 这篇文章讲得比较清晰，但是画的图相对容易理解，但是不完全吻合Doug Lea在文章所描述的意思。</li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007403873">Netty源码分析</a> 目前网上最好的Netty源码分析</li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/netty-threading-model">Netty 系列之 Netty 线程模型</a> 这文章线程模型总结的比较细致</li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/8805">单服务器高性能模式：Reactor与Proactor</a> 这文章介绍了Reactor模型以及Proactor模型</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/12/Java%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Reactor%E6%A8%A1%E5%9E%8B/" data-id="cltbach28000i3kr1dco9em56" data-title="Java高性能网络编程--Reactor模型" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/04/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%9B%9B-Promise-%E4%B8%8E-Future-%E5%8F%8C%E5%AD%90%E6%98%9F%E7%9A%84%E7%A7%98%E5%AF%86/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Netty 源码分析之 四 Promise 与 Future: 双子星的秘密
        
      </div>
    </a>
  
  
    <a href="/2020/05/14/%E8%AE%A4%E8%AF%86Java-NIO/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">认识 Java NIO</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS%E5%8E%9F%E7%90%86/" rel="tag">CAS原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" rel="tag">代码整洁之道</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" rel="tag">垃圾回收器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" rel="tag">垃圾收集器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" rel="tag">性能分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" rel="tag">文件描述符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/" rel="tag">生产问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="tag">类加载机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" rel="tag">输入输出流</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CAS%E5%8E%9F%E7%90%86/" style="font-size: 10px;">CAS原理</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JVM/" style="font-size: 18.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/NIO/" style="font-size: 11.67px;">NIO</a> <a href="/tags/Netty/" style="font-size: 13.33px;">Netty</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Spring/" style="font-size: 16.67px;">Spring</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" style="font-size: 10px;">代码整洁之道</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" style="font-size: 13.33px;">垃圾回收器</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" style="font-size: 10px;">垃圾收集器</a> <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" style="font-size: 10px;">性能分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" style="font-size: 10px;">文件描述符</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 20px;">源码分析</a> <a href="/tags/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/" style="font-size: 13.33px;">生产问题</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">类加载机制</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a> <a href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" style="font-size: 10px;">输入输出流</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-6-ZGC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">Java 虚拟机原理 (六) ZGC 垃圾收集器</a>
          </li>
        
          <li>
            <a href="/2021/02/09/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-3-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%B7%E6%81%A9%E6%B3%95%E5%88%99/">生产问题(3) 应用开发过程中的海恩法则</a>
          </li>
        
          <li>
            <a href="/2021/02/07/%E6%B7%B1%E5%85%A5-MySQL-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">深入 MySQL (六) 常见问题汇总</a>
          </li>
        
          <li>
            <a href="/2021/02/06/%E6%B7%B1%E5%85%A5-MySQL-5-%E9%94%81/">深入 MySQL (五) 锁</a>
          </li>
        
          <li>
            <a href="/2021/02/05/%E6%B7%B1%E5%85%A5-MySQL-4-%E7%B4%A2%E5%BC%95/">深入 MySQL (四) 索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 <br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>