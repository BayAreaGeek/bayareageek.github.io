<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Netty 源码分析之 五 奔腾的血液: ByteBuf | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="本文是永顺大牛写的系列教程《源码之下无秘密 ── 做最好的 Netty 源码分析教程》的续写章节。本章主要介绍Netty中用来承接数据的ByteBuf的底层实现原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 源码分析之 五 奔腾的血液: ByteBuf">
<meta property="og:url" content="http://example.com/2020/07/09/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E4%BA%94-%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2-ByteBuf/index.html">
<meta property="og:site_name">
<meta property="og:description" content="本文是永顺大牛写的系列教程《源码之下无秘密 ── 做最好的 Netty 源码分析教程》的续写章节。本章主要介绍Netty中用来承接数据的ByteBuf的底层实现原理。">
<meta property="og:locale">
<meta property="og:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2FNetty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%BA%94%20%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2%3A%20ByteBuf%2Fclass-diagram.png">
<meta property="og:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2FNetty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%BA%94%20%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2%3A%20ByteBuf%2FByteBuf%E8%AF%BB%E5%86%99%E6%8C%87%E9%92%88.png">
<meta property="article:published_time" content="2020-07-09T15:30:20.000Z">
<meta property="article:modified_time" content="2024-02-18T13:17:51.574Z">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2FNetty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%BA%94%20%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2%3A%20ByteBuf%2Fclass-diagram.png">
  
    <link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Netty-源码分析之-五-奔腾的血液-ByteBuf" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/09/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E4%BA%94-%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2-ByteBuf/" class="article-date">
  <time class="dt-published" datetime="2020-07-09T15:30:20.000Z" itemprop="datePublished">2020-07-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Netty 源码分析之 五 奔腾的血液: ByteBuf
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文是永顺大牛写的系列教程<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007282628#comment-area">《源码之下无秘密 ── 做最好的 Netty 源码分析教程》</a>的续写章节。本章主要介绍Netty中用来承接数据的ByteBuf的底层实现原理。</p>
<span id="more"></span>
<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>永顺前辈已写完的章节有如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006824091">Netty 源码分析之 番外篇 Java NIO 的前生今世</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007282597">Netty 源码分析之 零 磨刀不误砍柴工 源码分析环境搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007282789">Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007283053">Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (服务器端)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007308934">Netty 源码分析之 二 贯穿 Netty 的大动脉 ── ChannelPipeline (一)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007309311">Netty 源码分析之 二 贯穿 Netty 的大动脉 ── ChannelPipeline (二)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007403873">Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(一)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007403937">Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(二)</a></li>
</ul>
<p>笔者尝试续写的章节：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.duval.top/2020/07/04/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%9B%9B-Promise-%E4%B8%8E-Future-%E5%8F%8C%E5%AD%90%E6%98%9F%E7%9A%84%E7%A7%98%E5%AF%86/">Netty 源码分析之 四 Promise 与 Future: 双子星的秘密</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.duval.top/2020/07/09/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E4%BA%94-%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2-ByteBuf/">Netty 源码分析之 五 奔腾的血液: ByteBuf</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.duval.top/2020/07/15/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%85%AD-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8-Handler/">Netty 源码分析之 六 流水线处理器: Handler</a></li>
</ul>
<p><em>本文使用的netty版本为4.1.33.Final</em></p>
<h2 id="ByteBuf与ByteBuffer"><a href="#ByteBuf与ByteBuffer" class="headerlink" title="ByteBuf与ByteBuffer"></a>ByteBuf与ByteBuffer</h2><p>我们在<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006824155">《Java NIO 的前生今世 之三 NIO Buffer 详解》</a>以及<a target="_blank" rel="noopener" href="https://blog.duval.top/2020/05/14/%E8%AE%A4%E8%AF%86Java-NIO/">《认识 Java NIO》</a>已经详细了解了NIO Buffer。这里先回忆下NIO Buffer的一些特性：</p>
<ul>
<li>ByteBuffer底层实现包含四个关键字段，并满足大小关系：mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity；</li>
<li>ByteBuffer存在写模式和读模式两种状态，内部方法可以触发状态切换，比如flip方法从写状态切换为读状态；</li>
<li>不同类型的ByteBuffer支持不同的数据类型，包括ByteBuffer、ShortBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer等类型。</li>
</ul>
<p>Netty的ByteBuf的底层实现有些许类似，但相比ByteBuffer实现了非常多扩展，并摒弃了一些不足：</p>
<ul>
<li>不区分读写状态，不需要切换状态；</li>
<li>支持池化，避免频繁的GC回收；</li>
<li>支持引用计数；</li>
<li>类型兼容（同一个ByteBuf可以承载各种数据类型）；</li>
<li>支持Unsafe操作的ByteBuf；</li>
<li>支持堆外和堆内两种ByteBuf；</li>
<li>支持零拷贝的复合类型CompositeByteBuf；</li>
<li>…</li>
</ul>
<h2 id="ByteBuf继承关系"><a href="#ByteBuf继承关系" class="headerlink" title="ByteBuf继承关系"></a>ByteBuf继承关系</h2><p>我们先来看看ByteBuf的类图：<br><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2FNetty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%BA%94%20%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2%3A%20ByteBuf%2Fclass-diagram.png" alt="class-diagram.png"></p>
<p>ByteBuf以及其子类的命名非常规整，仅从名字上我们就可以将各个子类划分为以下几类：</p>
<ul>
<li>池化和非池化的ByteBuf，例如：PooledHeapByteBuf 和 UnpooledHeapByteBuf；</li>
<li>含Unsafe操作的ByteBuf，例如：PooledUnsafeHeapByteBuf;</li>
<li>分片类型的ByteBuf，例如：PooledSliceByteBuf和PooledDuplicatedByteBuf；</li>
<li>组合ByteBuf，例如：CompositeBuf;</li>
<li>实现了引用计数的ByteBuf。</li>
</ul>
<p>以上各种类型的都会在下文展开分析。</p>
<h2 id="ByteBuf的读写指针"><a href="#ByteBuf的读写指针" class="headerlink" title="ByteBuf的读写指针"></a>ByteBuf的读写指针</h2><p>类似NIO ByteBuffer，ByteBuf底层实现也是字节数组，也同样由读写指针来控制读写位置。在ByteBuf的继承类AbstractByteBuf中定义了以下读写指针字段：</p>
<pre><code class="java">    // 当前读指针
    int readerIndex;
    // 当前写指针
    int writerIndex;
    // 暂存的读指针
    private int markedReaderIndex;
    // 暂存的写指针
    private int markedWriterIndex;
    // 最大容量
    private int maxCapacity;
</code></pre>
<p>需要注意的事maxCapacity是对底层字节数组进行扩容的最大容量，并不是当前容量capacity。通过这几个指针，其实可以将字节数组划分为以下几部分：</p>
<p><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2FNetty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%BA%94%20%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2%3A%20ByteBuf%2FByteBuf%E8%AF%BB%E5%86%99%E6%8C%87%E9%92%88.png" alt="ByteBuf读写指针.png"></p>
<p>有如下性质：</p>
<ul>
<li>每读取一个字节，readerIndex递增1；直到readerIndex等于writerIndex，表示ByteBuf已经不可读；</li>
<li>每写入一个字节，writerIndex递增1；直到writerIndex等于capacity，表示ByteBuf已经不可写；</li>
<li>当writerIndex等于capacity表示底层字节数组需要扩容，且最大扩容不能超过max capacity。</li>
</ul>
<p>有如上性质，可以推出以下ByteBuf的一些方法实现：</p>
<ul>
<li>readableBytes()：可读字节数 –&gt; this.writerIndex - this.readerIndex</li>
<li>writableBytes()：可写字节数 –&gt; this.capacity - this.writerIndex</li>
<li>isReadable()：是否可读 –&gt; this.writerIndex - this.readerIndex &gt; 0</li>
<li>isWritable()：是否可写 –&gt; this.capacity - this.writerIndex &gt; 0</li>
</ul>
<p>更多方法见下。</p>
<h2 id="ByteBuf接口常用方法"><a href="#ByteBuf接口常用方法" class="headerlink" title="ByteBuf接口常用方法"></a>ByteBuf接口常用方法</h2><p>ByteBuf继承了Comparable和RefrenceCounted，其中后者是支持引用计数的接口，它的核心方法包含两个：</p>
<pre><code class="java">    // 引用数加1
    ReferenceCounted retain();
    // 引用数减1，如果引用数减为0，则释放该对象。
    // 如果该对象被释放则返回true，否则返回false。
    // 注意：子类实现其实是减2，后文会提到。
    boolean release();
</code></pre>
<p>再来看ByteBuf的核心方法：</p>
<ul>
<li>容量有关方法</li>
</ul>
<pre><code class="java">    // 1.返回当前容量
    public abstract int capacity();
    // 2.调整当前容量
    public abstract ByteBuf capacity(int newCapacity);
    // 3.最大容量（capacity的最大上限）
    public abstract int maxCapacity();
</code></pre>
<p>注意 capacity() &lt;&#x3D; maxCapacity()。</p>
<ul>
<li>读写指针有关方法</li>
</ul>
<pre><code class="java">    // 读写指针相关方法
    // 1.获取当前读指针
    public abstract int readerIndex();
    // 2.设置当前读指针
    public abstract ByteBuf readerIndex(int readerIndex);
    // 3.获取当前写指针
    public abstract int writerIndex();
    // 4.设置当前写指针
    public abstract ByteBuf writerIndex(int writerIndex);
    // 5.同时设置读写指针
    public abstract ByteBuf setIndex(int readerIndex, int writerIndex);
    // 6.获取可读字节数(this.writerIndex - this.readerIndex)
    public abstract int readableBytes();
    // 7.获取可写字节数(this.capacity - this.writerIndex)
    public abstract int writableBytes();
    // 8.获取最大可写字节数 (this.maxCapacity - this.writerIndex)&#125;
    public abstract int maxWritableBytes();
    // 9.是否可读(this.writerIndex - this.readerIndex)
    public abstract boolean isReadable();
    // 10.是否可写(this.capacity - this.writerIndex)
    public abstract boolean isWritable();
    // 11.清空(相当于setIndex(0, 0))
    public abstract ByteBuf clear();
    // 12.记录读指针
    public abstract ByteBuf markReaderIndex();
    // 13.从记录中恢复读指针
    public abstract ByteBuf resetReaderIndex();
    // 14.记录写指针 
    public abstract ByteBuf markWriterIndex();
    // 15.从记录中恢复写指针
    public abstract ByteBuf resetWriterIndex();
    // 16.丢弃已读字节
    public abstract ByteBuf discardReadBytes();
</code></pre>
<p>上述方法都是围绕着readerIndex、writerIndex、capital、maxcapital等四个值衍生的方法。实现都非常类似而简单。</p>
<ul>
<li>随机读写数据有关方法</li>
</ul>
<pre><code class="java">
    // 随机读写数据
    // ... 这部分类似的方法非常多，以下只列举一部分 ...
    // 1.从指定位置读取数据
    public abstract boolean getBoolean(int index);
    public abstract short getUnsignedByte(int index);
    public abstract short getShort(int index);
    public abstract int getUnsignedShort(int index);
    public abstract int   getInt(int index);
    public abstract long  getLong(int index);
    public abstract double getDouble(int index);
    public abstract short getShortLE(int index);（LE：Little Endian byte order，表示小端序，下同）
    public abstract int   getIntLE(int index);
    public abstract long  getLongLE(int index);
    // 略...
    // 2.在指定位置写入数据
    public abstract ByteBuf setBoolean(int index, boolean value);
    public abstract ByteBuf setByte(int index, int value);
    public abstract ByteBuf setShortLE(int index, int value);
    public abstract ByteBuf setInt(int index, int value);
    public abstract ByteBuf setIntLE(int index, int value);
    // 略... 
</code></pre>
<p>上述方法支持指定位置的读写数据，其中读数据并不会改变指针值。</p>
<ul>
<li>顺序读写数据有关方法。</li>
</ul>
<pre><code class="java">    // 1. 在readerIndex位置读取数据并移动指针
    public abstract boolean readBoolean();
    public abstract byte  readByte();
    public abstract short readShort();
    public abstract short readShortLE();
    public abstract int   readInt();
    public abstract int   readIntLE();
    // 略...
    // 2. 在位置写入数据并移动指针
    public abstract ByteBuf writeBoolean(boolean value);
    public abstract ByteBuf writeByte(int value);
    public abstract ByteBuf writeShort(int value);
    public abstract ByteBuf writeShortLE(int value);
    public abstract ByteBuf writeInt(int value);
    public abstract ByteBuf writeIntLE(int value);
    // 略...
</code></pre>
<p>上述方法从读(或写)指针位置顺序往后读(或写)数据，并移动读(或写)指针。</p>
<ul>
<li>分片相关方法</li>
</ul>
<pre><code class="java">    public abstract ByteBuf slice();
    public abstract ByteBuf slice(int index, int length);
    public abstract ByteBuf duplicate();
    public abstract ByteBuf retainedSlice(); // 更新引用计数
    public abstract ByteBuf retainedDuplicate(); // 更新引用计数
</code></pre>
<p>ByteBuf支持分片获取，实现快速的低成本浅复制。</p>
<ul>
<li>其他方法</li>
</ul>
<pre><code class="java">    // 判断底层是否为NIO direct buffer
    public abstract boolean isDirect();
</code></pre>
<h2 id="ByteBuf浅复制实现"><a href="#ByteBuf浅复制实现" class="headerlink" title="ByteBuf浅复制实现"></a>ByteBuf浅复制实现</h2><p>上一节我们提到了ByteBuf支持浅复制分片，其中分为slice浅复制和duplicate浅复制。duplicate与slice的区别是，duplicate是对整个ByteBuf的浅复制，而slice只是对ByteBuf中的一部分进行浅复制。</p>
<p>ByteBuf的浅复制分片其实就是与原来的ByteBuf共享同一个存储空间，并且也可以被多个分片同时共享。以slice(int index, int length)方法为例：</p>
<pre><code class="java">    // io.netty.buffer.AbstractByteBuf.java

    @Override
    public ByteBuf slice(int index, int length) &#123;
        ensureAccessible();
        return new UnpooledSlicedByteBuf(this, index, length);
    &#125;
</code></pre>
<p>slice方法内非常简单，只是新建了一个分片对象<em>UnpooledSlicedByteBuf</em>，构造函数传入了当前ByteBuf（this）、开始索引（index）以及分片长度（length）；</p>
<p>在父类的构造行数里，对该分片对象进行了初始化：</p>
<pre><code class="java">    // 被分片的ByteBuf
    private final ByteBuf buffer;
    // 偏移量
    private final int adjustment;

    AbstractUnpooledSlicedByteBuf(ByteBuf buffer, int index, int length) &#123;
        super(length);
        checkSliceOutOfBounds(index, length, buffer);
        if (buffer instanceof AbstractUnpooledSlicedByteBuf) &#123;
            // 如果传入的是slice分片，则需要叠加其偏移量
            this.buffer = ((AbstractUnpooledSlicedByteBuf) buffer).buffer;
            adjustment = ((AbstractUnpooledSlicedByteBuf) buffer).adjustment + index;
        &#125; else if (buffer instanceof DuplicatedByteBuf) &#123;
            // 如果传入的是dulicated分片，不需要叠加(因为其偏移量为0)
            this.buffer = buffer.unwrap();
            adjustment = index;
        &#125; else &#123;
            this.buffer = buffer;
            adjustment = index;
        &#125;
        // 初始化当前最大容量，对分片来说，最大容量不能超过length
        initLength(length);
        // 初始化写指针
        writerIndex(length);
    &#125;
</code></pre>
<p>可见，slice分片仅仅是对原ByteBuf进行了一层封装，并没有发生任何内存复制行为，所以是非常高效快捷的操作。</p>
<p>与slice类似，duplicate也是如此手法。唯一不同是，duplicate是对整个ByteBuf进行浅复制：</p>
<pre><code class="java">
    public DuplicatedByteBuf(ByteBuf buffer) &#123;
        this(buffer, buffer.readerIndex(), buffer.writerIndex());
    &#125;

    DuplicatedByteBuf(ByteBuf buffer, int readerIndex, int writerIndex) &#123;
        super(buffer.maxCapacity());

        if (buffer instanceof DuplicatedByteBuf) &#123;
            this.buffer = ((DuplicatedByteBuf) buffer).buffer;
        &#125; else if (buffer instanceof AbstractPooledDerivedByteBuf) &#123;
            this.buffer = buffer.unwrap();
        &#125; else &#123;
            this.buffer = buffer;
        &#125;
        // 直接复用原ByteBuf的读写指针
        setIndex(readerIndex, writerIndex);
        markReaderIndex();
        markWriterIndex();
    &#125;
</code></pre>
<p><strong>值得注意的是，无论是slice还是duplicate，都没有调用retain()方法来改变底层ByteBuf的引用计数。</strong> 所以，如果底层ByteBuf调用release()后被释放，那么所有基于该ByteBuf的浅复制对象都不能进行读写。所以要确保浅复制实例的使用安全，需要通过调用一次retain()方法来递增底层ByteBuf的引用计数；然后在浅复制实例使用结束后，再调用一次release()来递减底层ByteBuf的引用计数。</p>
<h2 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h2><p>CompositeByteBuf也是一个非常典型的ByteBuf，用来将多个ByteBuf组合在一起，形成一个逻辑上的ByteBuf。这点和分片ByteBuf非常类似，都属于在逻辑层面上避免拷贝，实现所谓的“零复制”（Zero Copy)。</p>
<p>CompositeByteBuf在内部维护一个可扩容的components数组，所有被组合的ByteBuf被封装为Component对象，对象中缓存了该ByteBuf的偏移量adjustment、开始索引offset、结束索引endOffset等。</p>
<pre><code class="java">    private Component[] components; // resized when needed

    private static final class Component &#123;
        final ByteBuf buf;
        int adjustment;
        int offset;
        int endOffset;

        private ByteBuf slice; // cached slice, may be null
    &#125;
</code></pre>
<p>对CompositeByteBuf的读写，需要先在components数组里二分查找对应索引所在的Component对象，然后对Component对象所包装的ByteBuf进行读写。如下：</p>
<pre><code class="java">    @Override
    protected byte _getByte(int index) &#123;
        // 确定索引index所在的Component对象
        Component c = findComponent0(index);
        // 对Component对象所包装的ByteBuf进行读写
        return c.buf.getByte(c.idx(index));
    &#125;

    private Component findComponent0(int offset) &#123;
        // 先检查最近访问的Component是否满足条件
        Component la = lastAccessed;
        if (la != null &amp;&amp; offset &gt;= la.offset &amp;&amp; offset &lt; la.endOffset) &#123;
           return la;
        &#125;
        // 否则二分查找
        return findIt(offset);
    &#125;

    // 二分查找
    private Component findIt(int offset) &#123;
        for (int low = 0, high = componentCount; low &lt;= high;) &#123;
            int mid = low + high &gt;&gt;&gt; 1;
            Component c = components[mid];
            if (offset &gt;= c.endOffset) &#123;
                low = mid + 1;
            &#125; else if (offset &lt; c.offset) &#123;
                high = mid - 1;
            &#125; else &#123;
                lastAccessed = c;
                return c;
            &#125;
        &#125;

        throw new Error(&quot;should not reach here&quot;);
    &#125;
</code></pre>
<p>CompositeByteBuf的核心思想大致如上，其他细节不作深究。</p>
<h2 id="ByteBuf引用计数实现"><a href="#ByteBuf引用计数实现" class="headerlink" title="ByteBuf引用计数实现"></a>ByteBuf引用计数实现</h2><h3 id="引用计数字段"><a href="#引用计数字段" class="headerlink" title="引用计数字段"></a>引用计数字段</h3><p>引用计数功能是在<em>AbstractReferenceCountedByteBuf</em>类中实现的。核心功能使用CAS原子操作和位运算实现。关键字段有两个：</p>
<pre><code class="java">    private static final AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater =
            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, &quot;refCnt&quot;);

    // even =&gt; &quot;real&quot; refcount is (refCnt &gt;&gt;&gt; 1); odd =&gt; &quot;real&quot; refcount is 0
    @SuppressWarnings(&quot;unused&quot;)
    private volatile int refCnt = 2;
</code></pre>
<p>refCntUpdater是修改refCnt字段的原子更新器。而refCnt是存储引用计数的字段。注意，当前ByteBuf的引用数为 refCnt &#x2F; 2，因此当refCnt等于1时，引用数为0。</p>
<h3 id="增加引用retain"><a href="#增加引用retain" class="headerlink" title="增加引用retain"></a>增加引用retain</h3><p>retain方法可以增加ByteBuf的引用计数。核心代码如下：</p>
<pre><code class="java">    @Override
    public ByteBuf retain() &#123;
        return retain0(1);
    &#125;

    private ByteBuf retain0(final int increment) &#123;
        // 将increment扩大两倍为adjustedIncrement
        int adjustedIncrement = increment &lt;&lt; 1; // 此处允许溢出，因为后边有判断溢出的逻辑
        // 将adjustedIncrement更新到refCnt，因此refCnt初始值为2，所以恒为偶数
        int oldRef = refCntUpdater.getAndAdd(this, adjustedIncrement);
        // 如果oldRef不是偶数，直接抛异常
        if ((oldRef &amp; 1) != 0) &#123;
            throw new IllegalReferenceCountException(0, increment);
        &#125;
        // 如果oldRef 和 oldRef + adjustedIncrement 正负异号，则意味着已经溢出。
        if ((oldRef &lt;= 0 &amp;&amp; oldRef + adjustedIncrement &gt;= 0)
                || (oldRef &gt;= 0 &amp;&amp; oldRef + adjustedIncrement &lt; oldRef)) &#123;
            // 发生溢出需要回滚adjustedIncrement
            refCntUpdater.getAndAdd(this, -adjustedIncrement);
            // 然后抛异常
            throw new IllegalReferenceCountException(realRefCnt(oldRef), increment);
        &#125;
        return this;
    &#125;
</code></pre>
<p>注释已经讲得很明白，这里再补充下：每次调用retain()，都会尝试给refCnt加2，所以确保了refCnt恒为偶数，也就是说当前引用数为refCnt &#x2F; 2。这里为啥设计为递增2而不是递增1，估计是位运算更加高效吧，而且实际应用中Integer.MAX_VALUE &#x2F; 2的引用数也是绰绰有余。</p>
<h3 id="释放引用release"><a href="#释放引用release" class="headerlink" title="释放引用release"></a>释放引用release</h3><p>恰恰相反，release()操作每次减少引用计数2，如下：</p>
<pre><code class="java">    @Override
    public boolean release() &#123;
        return release0(1);
    &#125;

    private boolean release0(int decrement) &#123;
        int rawCnt = nonVolatileRawCnt(), realCnt = toLiveRealCnt(rawCnt, decrement);
        if (decrement == realCnt) &#123;
            // 如果decrement == realCnt，意味着需要释放对象
            if (refCntUpdater.compareAndSet(this, rawCnt, 1)) &#123;
                deallocate();
                return true;
            &#125;
            return retryRelease0(decrement);
        &#125;
        return releaseNonFinal0(decrement, rawCnt, realCnt);
    &#125;

    private boolean releaseNonFinal0(int decrement, int rawCnt, int realCnt) &#123;
        if (decrement &lt; realCnt
                // all changes to the raw count are 2x the &quot;real&quot; change
                &amp;&amp; refCntUpdater.compareAndSet(this, rawCnt, rawCnt - (decrement &lt;&lt; 1))) &#123;
            return false;
        &#125;
        // 上述更新失败则调用重试方法
        return retryRelease0(decrement);
    &#125;

    private boolean retryRelease0(int decrement) &#123;
        // 死循环不断重试释放引用
        for (;;) &#123;
            int rawCnt = refCntUpdater.get(this), realCnt = toLiveRealCnt(rawCnt, decrement);
            if (decrement == realCnt) &#123;
                if (refCntUpdater.compareAndSet(this, rawCnt, 1)) &#123;
                    // 如果refCnt为1，意味着实际的引用数为1/2=0，所以需要释放掉
                    deallocate();
                    return true;
                &#125;
            &#125; else if (decrement &lt; realCnt) &#123;
                // 如果当前引用数realCnt大于decrement，则可以正常更新
                if (refCntUpdater.compareAndSet(this, rawCnt, rawCnt - (decrement &lt;&lt; 1))) &#123;
                    return false;
                &#125;
            &#125; else &#123;
                // 如果当前引用数realCnt小于decrement，则抛出引用异常
                throw new IllegalReferenceCountException(realCnt, -decrement);
            &#125;
            Thread.yield(); // this benefits throughput under high contention
        &#125;
    &#125;

    /**
     * Like &#123;@link #realRefCnt(int)&#125; but throws if refCnt == 0
     */
    private static int toLiveRealCnt(int rawCnt, int decrement) &#123;
        if ((rawCnt &amp; 1) == 0) &#123;
            // 如果是偶数，则引用数为rawCnt &gt;&gt;&gt; 1
            return rawCnt &gt;&gt;&gt; 1;
        &#125;
        // 如果是奇数，意味着该对象可能已经被释放掉
        throw new IllegalReferenceCountException(0, -decrement);
    &#125;
</code></pre>
<p><strong>release0算法流程：</strong></p>
<ul>
<li><ol>
<li>获取当前计数rawCnt，获取实际引用数realCnt；</li>
</ol>
</li>
<li><ol start="2">
<li>判断decrement是否等于realCnt；</li>
</ol>
</li>
<li><ul>
<li>2.1 如果相等，意味着本次release之后，对象需要被释放，尝试原子操作修改引用数；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>2.1.1 如果修改成功，直接释放对象并返回true；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>2.2.2 如果修改失败，调用retryRelease0进行循环重试释放；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>2.2 如果不相等，意味着本次release之后，对象依然存活，尝试调用releaseNonFinal0；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>2.2.1 如果decrement &lt; realCnt，且原子修改引用计数成功，直接返回false；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>2.2.2 否则，调用retryRelease0进行循环重试释放。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>retryRelease0算法流程：</strong></p>
<ul>
<li><ol>
<li>死循环开始；</li>
</ol>
</li>
<li><ol start="2">
<li>获取当前计数rawCnt，获取实际引用数realCnt；</li>
</ol>
</li>
<li><ol start="3">
<li>判断decrement &#x3D;&#x3D; realCnt；</li>
</ol>
</li>
<li><ul>
<li>3.1 如果相等，意味着本次release之后，对象需要被释放，尝试原子操作修改引用数；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>3.1.1 如果修改成功，直接释放对象并返回true；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>3.1.2 否则跳转6；</li>
</ul>
</li>
</ul>
</li>
<li><ol start="4">
<li>判断decrement &lt; realCnt；</li>
</ol>
</li>
<li><ul>
<li>4.1 如果成立，意味着本次release之后，对象依然存活，尝试原子更新引用计数；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>4.1.1 如果修改成功，直接返回false；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>4.1.2 否则跳转6；</li>
</ul>
</li>
</ul>
</li>
<li><ol start="5">
<li>其他情况（decrement &gt; realCnt) 直接抛异常；</li>
</ol>
</li>
<li><ol start="6">
<li>Thread.yield()；</li>
</ol>
</li>
<li><ol start="7">
<li>跳转到1。</li>
</ol>
</li>
</ul>
<h2 id="池化和非池化"><a href="#池化和非池化" class="headerlink" title="池化和非池化"></a>池化和非池化</h2><p>我们看到ByteBuf分为两类池化(Pooled)和非池化(Unpooled)。非池化的ByteBuf每次新建都会申请新的内存空间，并且用完即弃，给JVM的垃圾回收带来负担；而池化的ByteBuf通过内部栈来保存闲置的对象空间，每次新建ByteBuf的时候，优先向内部栈申请闲置的对象空间，并且用完之后重新归还给内部栈，从而减少了JVM的垃圾回收压力。</p>
<h3 id="非池化实现"><a href="#非池化实现" class="headerlink" title="非池化实现"></a>非池化实现</h3><p>非池化的ByteBuf实现非常简单粗暴。下边分别以UnpooledHeapByteBuf和UnpooledDirectByteBuf为例：</p>
<ul>
<li>对象分配<br>UnpooledHeapByteBuf在构造函数里直接新建了一个字节数组来保存数据：</li>
</ul>
<pre><code class="java">    private final ByteBufAllocator alloc;
    // 使用字节数组保存数据
    byte[] array;

    public UnpooledHeapByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) &#123;
        super(maxCapacity);

        checkNotNull(alloc, &quot;alloc&quot;);

        if (initialCapacity &gt; maxCapacity) &#123;
            throw new IllegalArgumentException(String.format(
                    &quot;initialCapacity(%d) &gt; maxCapacity(%d)&quot;, initialCapacity, maxCapacity));
        &#125;

        this.alloc = alloc;
        setArray(allocateArray(initialCapacity));
        setIndex(0, 0);
    &#125;
    // 分配字节数组
    protected byte [] allocateArray(int initialCapacity) &#123;
        return new byte[initialCapacity];
    &#125;
</code></pre>
<p>而UnpooledDirectByteBuf则在构造函数中直接新建了一个DirectBuffer：</p>
<pre><code class="java">    // 使用DirectBuffer保存数据
    private ByteBuffer buffer;
    public UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) &#123;
        super(maxCapacity);
        if (alloc == null) &#123;
            throw new NullPointerException(&quot;alloc&quot;);
        &#125;
        if (initialCapacity &lt; 0) &#123;
            throw new IllegalArgumentException(&quot;initialCapacity: &quot; + initialCapacity);
        &#125;
        if (maxCapacity &lt; 0) &#123;
            throw new IllegalArgumentException(&quot;maxCapacity: &quot; + maxCapacity);
        &#125;
        if (initialCapacity &gt; maxCapacity) &#123;
            throw new IllegalArgumentException(String.format(
                    &quot;initialCapacity(%d) &gt; maxCapacity(%d)&quot;, initialCapacity, maxCapacity));
        &#125;

        this.alloc = alloc;
        setByteBuffer(allocateDirect(initialCapacity));
    &#125;
    // 分配DirectBuffer
    protected ByteBuffer allocateDirect(int initialCapacity) &#123;
        return ByteBuffer.allocateDirect(initialCapacity);
    &#125;
</code></pre>
<ul>
<li>对象释放<br>UnpooledHeapByteBuf的释放全权交给JVM：</li>
</ul>
<pre><code class="java">    @Override
    protected void deallocate() &#123;
        freeArray(array);
        array = EmptyArrays.EMPTY_BYTES;
    &#125;

    protected void freeArray(byte[] array) &#123;
        // NOOP
    &#125;
</code></pre>
<p>而UnpooledDirectByteBuf则尝试主动释放其拥有的DirectBuffer：</p>
<pre><code class="java">    @Override
    protected void deallocate() &#123;
        ByteBuffer buffer = this.buffer;
        if (buffer == null) &#123;
            return;
        &#125;

        this.buffer = null;

        if (!doNotFree) &#123;
            // 如果DirectBuffer还没被释放，则尝试释放之
            freeDirect(buffer);
        &#125;
    &#125;

    /**
     * Free a direct &#123;@link ByteBuffer&#125;
     */
    protected void freeDirect(ByteBuffer buffer) &#123;
        PlatformDependent.freeDirectBuffer(buffer);
    &#125;
</code></pre>
<h3 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h3><p>池化的ByteBuf都继承自PooledByteBuf<T>类，包括PooledHeapByteBuf、PooledDirectByteBuf、PooledUnsafeDirectByteBuf、PooledUnsafeHeapByteBuf。</p>
<p>这四个子类都持有一个回收器字段，例如，在PooledHeapByteBuf中有：</p>
<pre><code class="java">    private static final Recycler&lt;PooledHeapByteBuf&gt; RECYCLER = new Recycler&lt;PooledHeapByteBuf&gt;() &#123;
        @Override
        protected PooledHeapByteBuf newObject(Handle&lt;PooledHeapByteBuf&gt; handle) &#123;
            return new PooledHeapByteBuf(handle, 0);
        &#125;
    &#125;;
</code></pre>
<p>Recycler<T>是一个抽象类，所有的子类都要实现一个newObject方法，用于新建一个子类ByteBuf对象。</p>
<p>Recycler<T>本质上实现的是一个栈的功能，新建ByteBuf的时候，可以向Recycler<T>申请一个闲置对象；当ByteBuf使用完毕后，可以回收并归还给Recycler<T>。</p>
<ul>
<li><strong>申请ByteBuf</strong></li>
</ul>
<p>子类调用RECYCLER.get()来申请闲置对象，方法实现：</p>
<pre><code class="java">    public final T get() &#123;
        if (maxCapacityPerThread == 0) &#123;
            return newObject((Handle&lt;T&gt;) NOOP_HANDLE);
        &#125;
        // 尝试从栈中获取闲置对象
        Stack&lt;T&gt; stack = threadLocal.get();
        DefaultHandle&lt;T&gt; handle = stack.pop();
        if (handle == null) &#123;
            // 如果没有闲置对象，调用newObject新建一个新的对象。
            handle = stack.newHandle();
            handle.value = newObject(handle);
        &#125;
        return (T) handle.value;
    &#125;
</code></pre>
<p>可见，新建池化的ByteBuf都是优先从栈中获取闲置对象；当栈没有闲置对象再新建。值得注意的是，新建对象还传入了新建的handle，这个handle在对象回收阶段会使用到。</p>
<p>另外为了抹去历史的使用痕迹，每个新申请的ByteBuf对象，都会调用reuse方法进行初始化（以PooledDirectByteBuf为例）：</p>
<pre><code class="java">    static PooledDirectByteBuf newInstance(int maxCapacity) &#123;
        PooledDirectByteBuf buf = RECYCLER.get();
        buf.reuse(maxCapacity);
        return buf;
    &#125;
    /**
     * Method must be called before reuse this &#123;@link PooledByteBufAllocator&#125;
     */
    final void reuse(int maxCapacity) &#123;
        maxCapacity(maxCapacity);
        setRefCnt(1);
        setIndex0(0, 0);
        discardMarks();
    &#125;
</code></pre>
<ul>
<li><strong>回收ByteBuf</strong></li>
</ul>
<p>前面我们提到：当ByteBuf引用数为0的时候，会调用deallocate()方法进行释放。实现如下：</p>
<pre><code class="java">    @Override
    protected final void deallocate() &#123;
        if (handle &gt;= 0) &#123;
            final long handle = this.handle;
            this.handle = -1;
            memory = null;
            chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);
            tmpNioBuf = null;
            chunk = null;
            recycle();
        &#125;
    &#125;

    private void recycle() &#123;
        recyclerHandle.recycle(this);
    &#125;
</code></pre>
<p>如上，最后调用了handler进行回收。所谓的回收动作，其实就是放回栈中：</p>
<pre><code class="java">    static final class DefaultHandle&lt;T&gt; implements Handle&lt;T&gt; &#123;
        private int lastRecycledId;
        private int recycleId;

        boolean hasBeenRecycled;

        private Stack&lt;?&gt; stack;
        private Object value;

        DefaultHandle(Stack&lt;?&gt; stack) &#123;
            this.stack = stack;
        &#125;

        @Override
        public void recycle(Object object) &#123;
            if (object != value) &#123;
                throw new IllegalArgumentException(&quot;object does not belong to handle&quot;);
            &#125;

            Stack&lt;?&gt; stack = this.stack;
            if (lastRecycledId != recycleId || stack == null) &#123;
                throw new IllegalStateException(&quot;recycled already&quot;);
            &#125;
            // 将该handler重新放入栈中
            stack.push(this);
        &#125;
    &#125;
</code></pre>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><h3 id="Unsafe实现"><a href="#Unsafe实现" class="headerlink" title="Unsafe实现"></a>Unsafe实现</h3><p>还有一类使用了Unsafe操作的ByteBuf，例如：UnpooledUnsafeDirectByteBuf、UnpooledUnsafeHeapByteBuf、PooledUnsafeHeapByteBuf、PooledUnsafeDirectByteBuf。</p>
<p>这类ByteBuf的特点就是所有的读写操作都是用了sun.misc.Unsafe。如下：</p>
<pre><code class="java">    @Override
    protected byte _getByte(int index) &#123;
        return UnsafeByteBufUtil.getByte(addr(index));
    &#125;
</code></pre>
<p>而UnsafeByteBufUtil底层调用了sum.misc.Unsafe ：</p>
<pre><code class="java">    static byte getByte(long address) &#123;
        return UNSAFE.getByte(address);
    &#125;
</code></pre>
<p>而不是用Unsafe操作的ByteBuf，一般使用的是HeapByteBufUtil：</p>
<pre><code class="java">    @Override
    protected byte _getByte(int index) &#123;
        return HeapByteBufUtil.getByte(memory, idx(index));
    &#125;
</code></pre>
<p>而HeapByteBufUtil底层其实是简单的数组寻址：</p>
<pre><code class="java">    static byte getByte(byte[] memory, int index) &#123;
        return memory[index];
    &#125;
</code></pre>
<h3 id="Unsafe的性能提升"><a href="#Unsafe的性能提升" class="headerlink" title="Unsafe的性能提升"></a>Unsafe的性能提升</h3><p>Unsafe操作可以带来非常可观的性能提升，我写了一个简单的Benchmark测了下：</p>
<pre><code class="java">    @BenchmarkMode(&#123;Mode.Throughput&#125;)
    @Warmup(iterations = 1)
    @Measurement(iterations = 2, time = 1)
    @OutputTimeUnit(TimeUnit.SECONDS)
    @Fork(value = 2)
    @Threads(8)
    @State(Scope.Benchmark)
    @OperationsPerInvocation
    public class UnsafeBenchmark &#123;

        private static byte[] unsafeByteArray;

        private static byte[] safeByteArray;

        @Setup
        public void setup() &#123;
            unsafeByteArray = new byte[100];

            safeByteArray = new byte[100];
        &#125;

        @Benchmark
        public void unsafeMethod() &#123;
            int value = 1;
            UnsafeByteBufUtil.setByte(unsafeByteArray, 0, value);
            UnsafeByteBufUtil.getByte(unsafeByteArray, 0);

            long longValue = 100L;
            UnsafeByteBufUtil.setLong(unsafeByteArray, 0, longValue);
            UnsafeByteBufUtil.getLong(unsafeByteArray, 0);
        &#125;

        @Benchmark
        public void safeMethod() &#123;
            int value = 1;
            HeapByteBufUtil.setByte(safeByteArray, 0, value);
            HeapByteBufUtil.getByte(safeByteArray, 0);

            long longValue = 100L;
            HeapByteBufUtil.setLong(safeByteArray, 0, longValue);
            HeapByteBufUtil.getLong(safeByteArray, 0);
        &#125;

        public static void main(String[] args) throws RunnerException &#123;
            Options opt = new OptionsBuilder()
                    .include(UnsafeBenchmark.class.getSimpleName())
                    .build();

            new Runner(opt).run();
        &#125;
    &#125;
</code></pre>
<p>测试结果显示UnsafeByteBufUtil的性能非常优越：</p>
<pre><code class="bash">Benchmark                                Mode  Samples           Score            Error  Units
c.t.n.u.UnsafeBenchmark.safeMethod      thrpt        4   168827679.833 ±   71641561.636  ops/s
c.t.n.u.UnsafeBenchmark.unsafeMethod    thrpt        4  3141320463.164 ± 1204482723.948  ops/s
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了ByteBuf及其子类的实现原理，包括读写指针、常用方法、浅复制、引用计数、池化、Unsafe对象等实现原理。<br>通过上述深入分析，我们了解到ByteBuf在Netty中承担着运载数据的重要功能。如果将Netty比作一个完整的生物体，那么将ByteBuf比作血液，那就再恰当不过了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mycs2012/article/details/94591307">Netty ByteBuf（图解 ）之一</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/crazymakercircle/article/details/84205697">Netty ByteBuf（图解二）：API 图解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mycs2012/article/details/94591307">池化和非池化ByteBuf</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/09/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E4%BA%94-%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2-ByteBuf/" data-id="cltbach28000m3kr199gv3203" data-title="Netty 源码分析之 五 奔腾的血液: ByteBuf" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/15/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%85%AD-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8-Handler/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Netty 源码分析之 六 流水线处理器: Handler
        
      </div>
    </a>
  
  
    <a href="/2020/07/04/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%9B%9B-Promise-%E4%B8%8E-Future-%E5%8F%8C%E5%AD%90%E6%98%9F%E7%9A%84%E7%A7%98%E5%AF%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Netty 源码分析之 四 Promise 与 Future: 双子星的秘密</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS%E5%8E%9F%E7%90%86/" rel="tag">CAS原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" rel="tag">代码整洁之道</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" rel="tag">垃圾回收器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" rel="tag">垃圾收集器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" rel="tag">性能分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" rel="tag">文件描述符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/" rel="tag">生产问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="tag">类加载机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" rel="tag">输入输出流</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CAS%E5%8E%9F%E7%90%86/" style="font-size: 10px;">CAS原理</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JVM/" style="font-size: 18.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/NIO/" style="font-size: 11.67px;">NIO</a> <a href="/tags/Netty/" style="font-size: 13.33px;">Netty</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Spring/" style="font-size: 16.67px;">Spring</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" style="font-size: 10px;">代码整洁之道</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" style="font-size: 13.33px;">垃圾回收器</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" style="font-size: 10px;">垃圾收集器</a> <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" style="font-size: 10px;">性能分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" style="font-size: 10px;">文件描述符</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 20px;">源码分析</a> <a href="/tags/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/" style="font-size: 13.33px;">生产问题</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">类加载机制</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a> <a href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" style="font-size: 10px;">输入输出流</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-6-ZGC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">Java 虚拟机原理 (六) ZGC 垃圾收集器</a>
          </li>
        
          <li>
            <a href="/2021/02/09/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-3-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%B7%E6%81%A9%E6%B3%95%E5%88%99/">生产问题(3) 应用开发过程中的海恩法则</a>
          </li>
        
          <li>
            <a href="/2021/02/07/%E6%B7%B1%E5%85%A5-MySQL-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">深入 MySQL (六) 常见问题汇总</a>
          </li>
        
          <li>
            <a href="/2021/02/06/%E6%B7%B1%E5%85%A5-MySQL-5-%E9%94%81/">深入 MySQL (五) 锁</a>
          </li>
        
          <li>
            <a href="/2021/02/05/%E6%B7%B1%E5%85%A5-MySQL-4-%E7%B4%A2%E5%BC%95/">深入 MySQL (四) 索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 <br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>