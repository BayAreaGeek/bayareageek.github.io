<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Netty 源码分析之 五 奔腾的血液: ByteBuf | 湾区极客</title>
  <meta name="keywords" content=" Netty , 源码分析 ">
  <meta name="description" content="Netty 源码分析之 五 奔腾的血液: ByteBuf | 湾区极客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="湾区极客——大湾区技术极客聚集地">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="https://bayareageek.cn/about/index.html">
<meta property="og:site_name" content="湾区极客">
<meta property="og:description" content="湾区极客——大湾区技术极客聚集地">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-02T10:14:39.000Z">
<meta property="article:modified_time" content="2024-03-02T10:15:55.401Z">
<meta property="article:author" content="湾仔">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.png"/>
</a>
<div class="author">
    <span>湾仔</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/duval1024"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/duvalyang"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:869296790@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=869296790&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(33)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Java">
            
            Java
            <small>(17)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Spring">
            
            Spring
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="读书笔记">
            
            读书笔记
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="总结">
            
            总结
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="33">
<input type="hidden" id="yelog_site_word_count" value="90.3k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://bayareageek.cn/">湾区极客</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>代码整洁之道</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>读书笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>垃圾回收器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>垃圾收集器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>类加载机制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>生产问题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>输入输出流</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>文件描述符</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>线程池</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>性能分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>源码分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CAS原理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JVM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Netty</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NIO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Reactor</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 Java "
           href="/2021/04/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-6-ZGC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (六) ZGC 垃圾收集器">Java 虚拟机原理 (六) ZGC 垃圾收集器</span>
            <span class="post-date" title="2021-04-08 14:39:45">2021/04/08</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2021/02/09/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-3-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%B7%E6%81%A9%E6%B3%95%E5%88%99/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(3) 应用开发过程中的海恩法则">生产问题(3) 应用开发过程中的海恩法则</span>
            <span class="post-date" title="2021-02-09 22:18:16">2021/02/09</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/02/07/%E6%B7%B1%E5%85%A5-MySQL-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入 MySQL (六) 常见问题汇总">深入 MySQL (六) 常见问题汇总</span>
            <span class="post-date" title="2021-02-07 14:21:01">2021/02/07</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/06/%E6%B7%B1%E5%85%A5-MySQL-5-%E9%94%81/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (五) 锁">深入 MySQL (五) 锁</span>
            <span class="post-date" title="2021-02-06 22:19:08">2021/02/06</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/05/%E6%B7%B1%E5%85%A5-MySQL-4-%E7%B4%A2%E5%BC%95/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (四) 索引">深入 MySQL (四) 索引</span>
            <span class="post-date" title="2021-02-05 22:17:16">2021/02/05</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/04/%E6%B7%B1%E5%85%A5-MySQL-3-%E4%BA%8B%E5%8A%A1/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (三) 事务">深入 MySQL (三) 事务</span>
            <span class="post-date" title="2021-02-04 22:20:54">2021/02/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/01/30/%E6%B7%B1%E5%85%A5-MySQL-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (二) 文件系统">深入 MySQL (二) 文件系统</span>
            <span class="post-date" title="2021-01-30 12:00:39">2021/01/30</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/01/29/%E6%B7%B1%E5%85%A5-MySQL-1-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (一) 体系结构">深入 MySQL (一) 体系结构</span>
            <span class="post-date" title="2021-01-29 22:50:38">2021/01/29</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/11/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-5-G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (五) G1垃圾收集器深入">Java 虚拟机原理 (五) G1垃圾收集器深入</span>
            <span class="post-date" title="2021-01-11 01:00:07">2021/01/11</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/10/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-4-G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%A5%E9%97%A8/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (四) G1垃圾收集器入门">Java 虚拟机原理 (四) G1垃圾收集器入门</span>
            <span class="post-date" title="2021-01-10 21:40:07">2021/01/10</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/09/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"
           data-tag="JVM,Java,垃圾收集器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (三) 垃圾收集">Java 虚拟机原理 (三) 垃圾收集</span>
            <span class="post-date" title="2021-01-09 22:50:07">2021/01/09</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-2-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E5%9B%9E%E6%94%B6/"
           data-tag="JVM,Java"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (二) 对象创建与回收">Java 虚拟机原理 (二) 对象创建与回收</span>
            <span class="post-date" title="2021-01-08 23:56:07">2021/01/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/07/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-1-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"
           data-tag="JVM,Java"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (一) 内存划分">Java 虚拟机原理 (一) 内存划分</span>
            <span class="post-date" title="2021-01-07 22:56:07">2021/01/07</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/28/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1-Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"
           data-tag="Java,类加载机制"
           data-author="" >
            <span class="post-title" title="一文彻底掌握 Java 类加载机制">一文彻底掌握 Java 类加载机制</span>
            <span class="post-date" title="2020-12-28 22:11:49">2020/12/28</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java-IO%E7%B1%BB%E5%BA%93/"
           data-tag="Java,IO"
           data-author="" >
            <span class="post-title" title="一文彻底掌握Java IO类库">一文彻底掌握Java IO类库</span>
            <span class="post-date" title="2020-12-23 22:57:44">2020/12/23</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"
           data-tag="Java,文件描述符,输入输出流"
           data-author="" >
            <span class="post-title" title="深入理解Java文件输入输出流和文件描述符">深入理解Java文件输入输出流和文件描述符</span>
            <span class="post-date" title="2020-12-16 22:03:33">2020/12/16</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2020/12/15/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-2-ExceptionInInitializerError%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E8%A2%AB%E5%90%9E/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(2) ExceptionInInitializerError导致线程池中的线程异常被吞">生产问题(2) ExceptionInInitializerError导致线程池中的线程异常被吞</span>
            <span class="post-date" title="2020-12-15 17:26:29">2020/12/15</span>
        </a>
        
        
        <a  class="全部文章 读书笔记 "
           href="/2020/11/14/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"
           data-tag="读书笔记,代码整洁之道"
           data-author="" >
            <span class="post-title" title="《代码整洁之道》">《代码整洁之道》</span>
            <span class="post-date" title="2020-11-14 17:01:02">2020/11/14</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/10/26/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%89-%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之三 常用扩展点">再读Spring源码之三 常用扩展点</span>
            <span class="post-date" title="2020-10-26 18:31:25">2020/10/26</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/10/07/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BA%8C-FactoryBean/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之二 FactoryBean">再读Spring源码之二 FactoryBean</span>
            <span class="post-date" title="2020-10-07 21:00:39">2020/10/07</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/08/21/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%80-Spring%E5%A6%82%E4%BD%95%E5%AF%B9%E4%BB%98%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之一 Spring如何对付循环引用">再读Spring源码之一 Spring如何对付循环引用</span>
            <span class="post-date" title="2020-08-21 20:59:52">2020/08/21</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/15/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%85%AD-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8-Handler/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 六 流水线处理器: Handler">Netty 源码分析之 六 流水线处理器: Handler</span>
            <span class="post-date" title="2020-07-15 22:15:35">2020/07/15</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/09/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E4%BA%94-%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2-ByteBuf/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 五 奔腾的血液: ByteBuf">Netty 源码分析之 五 奔腾的血液: ByteBuf</span>
            <span class="post-date" title="2020-07-09 23:30:20">2020/07/09</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/04/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%9B%9B-Promise-%E4%B8%8E-Future-%E5%8F%8C%E5%AD%90%E6%98%9F%E7%9A%84%E7%A7%98%E5%AF%86/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 四 Promise 与 Future: 双子星的秘密">Netty 源码分析之 四 Promise 与 Future: 双子星的秘密</span>
            <span class="post-date" title="2020-07-04 16:10:56">2020/07/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/06/12/Java%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Reactor%E6%A8%A1%E5%9E%8B/"
           data-tag="NIO,Reactor"
           data-author="" >
            <span class="post-title" title="Java高性能网络编程--Reactor模型">Java高性能网络编程--Reactor模型</span>
            <span class="post-date" title="2020-06-12 14:48:28">2020/06/12</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/05/14/%E8%AE%A4%E8%AF%86Java-NIO/"
           data-tag="NIO"
           data-author="" >
            <span class="post-title" title="认识 Java NIO">认识 Java NIO</span>
            <span class="post-date" title="2020-05-14 15:27:54">2020/05/14</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2020/02/11/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-1-Java%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(1) Java进程CPU占用过高">生产问题(1) Java进程CPU占用过高</span>
            <span class="post-date" title="2020-02-11 21:49:14">2020/02/11</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/01/05/%E6%B7%B1%E5%85%A5JAVA%E8%AF%AD%E8%A8%80%E2%80%94CAS%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"
           data-tag="CAS原理"
           data-author="" >
            <span class="post-title" title="深入JAVA语言—CAS原理剖析">深入JAVA语言—CAS原理剖析</span>
            <span class="post-date" title="2020-01-05 18:16:26">2020/01/05</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/10/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903-%E5%AF%B9Bean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析3-对Bean循环依赖的处理">Spring源码分析3-对Bean循环依赖的处理</span>
            <span class="post-date" title="2018-10-12 15:47:01">2018/10/12</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-RESTful%20Web%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析1-RESTfulWeb启动过程">Spring源码分析1-RESTfulWeb启动过程</span>
            <span class="post-date" title="2018-07-12 11:47:01">2018/07/12</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%B7%E6%96%B0%E8%BF%87%E7%A8%8B/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析2-上下文刷新过程分析">Spring源码分析2-上下文刷新过程分析</span>
            <span class="post-date" title="2018-07-12 11:47:01">2018/07/12</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2017/08/10/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"
           data-tag="线程池"
           data-author="" >
            <span class="post-title" title="Java 线程池详解">Java 线程池详解</span>
            <span class="post-date" title="2017-08-10 16:47:18">2017/08/10</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2017/06/18/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"
           data-tag="JVM,性能分析"
           data-author="" >
            <span class="post-title" title="JVM性能监控工具总结">JVM性能监控工具总结</span>
            <span class="post-date" title="2017-06-18 16:47:54">2017/06/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Netty-源码分析之-五-奔腾的血液-ByteBuf" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Netty 源码分析之 五 奔腾的血液: ByteBuf</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java">Java</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">Netty</a>
            
            <a class="color5">源码分析</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-02-18 21:17:51'>2020-07-09 23:30</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:5.4k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D"><span class="toc-text">写在最前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuf%E4%B8%8EByteBuffer"><span class="toc-text">ByteBuf与ByteBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuf%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-text">ByteBuf继承关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuf%E7%9A%84%E8%AF%BB%E5%86%99%E6%8C%87%E9%92%88"><span class="toc-text">ByteBuf的读写指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuf%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">ByteBuf接口常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuf%E6%B5%85%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="toc-text">ByteBuf浅复制实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CompositeByteBuf"><span class="toc-text">CompositeByteBuf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuf%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">ByteBuf引用计数实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AD%97%E6%AE%B5"><span class="toc-text">引用计数字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8retain"><span class="toc-text">增加引用retain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8release"><span class="toc-text">释放引用release</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96%E5%92%8C%E9%9D%9E%E6%B1%A0%E5%8C%96"><span class="toc-text">池化和非池化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%B1%A0%E5%8C%96%E5%AE%9E%E7%8E%B0"><span class="toc-text">非池化实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96"><span class="toc-text">池化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe"><span class="toc-text">Unsafe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe%E5%AE%9E%E7%8E%B0"><span class="toc-text">Unsafe实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-text">Unsafe的性能提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是永顺大牛写的系列教程<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007282628#comment-area">《源码之下无秘密 ── 做最好的 Netty 源码分析教程》</a>的续写章节。本章主要介绍Netty中用来承接数据的ByteBuf的底层实现原理。</p>
<span id="more"></span>
<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>永顺前辈已写完的章节有如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006824091">Netty 源码分析之 番外篇 Java NIO 的前生今世</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007282597">Netty 源码分析之 零 磨刀不误砍柴工 源码分析环境搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007282789">Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007283053">Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (服务器端)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007308934">Netty 源码分析之 二 贯穿 Netty 的大动脉 ── ChannelPipeline (一)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007309311">Netty 源码分析之 二 贯穿 Netty 的大动脉 ── ChannelPipeline (二)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007403873">Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(一)</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007403937">Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(二)</a></li>
</ul>
<p>笔者尝试续写的章节：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.duval.top/2020/07/04/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%9B%9B-Promise-%E4%B8%8E-Future-%E5%8F%8C%E5%AD%90%E6%98%9F%E7%9A%84%E7%A7%98%E5%AF%86/">Netty 源码分析之 四 Promise 与 Future: 双子星的秘密</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.duval.top/2020/07/09/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E4%BA%94-%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2-ByteBuf/">Netty 源码分析之 五 奔腾的血液: ByteBuf</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.duval.top/2020/07/15/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%85%AD-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8-Handler/">Netty 源码分析之 六 流水线处理器: Handler</a></li>
</ul>
<p><em>本文使用的netty版本为4.1.33.Final</em></p>
<h2 id="ByteBuf与ByteBuffer"><a href="#ByteBuf与ByteBuffer" class="headerlink" title="ByteBuf与ByteBuffer"></a>ByteBuf与ByteBuffer</h2><p>我们在<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006824155">《Java NIO 的前生今世 之三 NIO Buffer 详解》</a>以及<a target="_blank" rel="noopener" href="https://blog.duval.top/2020/05/14/%E8%AE%A4%E8%AF%86Java-NIO/">《认识 Java NIO》</a>已经详细了解了NIO Buffer。这里先回忆下NIO Buffer的一些特性：</p>
<ul>
<li>ByteBuffer底层实现包含四个关键字段，并满足大小关系：mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity；</li>
<li>ByteBuffer存在写模式和读模式两种状态，内部方法可以触发状态切换，比如flip方法从写状态切换为读状态；</li>
<li>不同类型的ByteBuffer支持不同的数据类型，包括ByteBuffer、ShortBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer等类型。</li>
</ul>
<p>Netty的ByteBuf的底层实现有些许类似，但相比ByteBuffer实现了非常多扩展，并摒弃了一些不足：</p>
<ul>
<li>不区分读写状态，不需要切换状态；</li>
<li>支持池化，避免频繁的GC回收；</li>
<li>支持引用计数；</li>
<li>类型兼容（同一个ByteBuf可以承载各种数据类型）；</li>
<li>支持Unsafe操作的ByteBuf；</li>
<li>支持堆外和堆内两种ByteBuf；</li>
<li>支持零拷贝的复合类型CompositeByteBuf；</li>
<li>…</li>
</ul>
<h2 id="ByteBuf继承关系"><a href="#ByteBuf继承关系" class="headerlink" title="ByteBuf继承关系"></a>ByteBuf继承关系</h2><p>我们先来看看ByteBuf的类图：<br><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2FNetty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%BA%94%20%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2%3A%20ByteBuf%2Fclass-diagram.png" alt="class-diagram.png"></p>
<p>ByteBuf以及其子类的命名非常规整，仅从名字上我们就可以将各个子类划分为以下几类：</p>
<ul>
<li>池化和非池化的ByteBuf，例如：PooledHeapByteBuf 和 UnpooledHeapByteBuf；</li>
<li>含Unsafe操作的ByteBuf，例如：PooledUnsafeHeapByteBuf;</li>
<li>分片类型的ByteBuf，例如：PooledSliceByteBuf和PooledDuplicatedByteBuf；</li>
<li>组合ByteBuf，例如：CompositeBuf;</li>
<li>实现了引用计数的ByteBuf。</li>
</ul>
<p>以上各种类型的都会在下文展开分析。</p>
<h2 id="ByteBuf的读写指针"><a href="#ByteBuf的读写指针" class="headerlink" title="ByteBuf的读写指针"></a>ByteBuf的读写指针</h2><p>类似NIO ByteBuffer，ByteBuf底层实现也是字节数组，也同样由读写指针来控制读写位置。在ByteBuf的继承类AbstractByteBuf中定义了以下读写指针字段：</p>
<pre><code class="java">    // 当前读指针
    int readerIndex;
    // 当前写指针
    int writerIndex;
    // 暂存的读指针
    private int markedReaderIndex;
    // 暂存的写指针
    private int markedWriterIndex;
    // 最大容量
    private int maxCapacity;
</code></pre>
<p>需要注意的事maxCapacity是对底层字节数组进行扩容的最大容量，并不是当前容量capacity。通过这几个指针，其实可以将字节数组划分为以下几部分：</p>
<p><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2FNetty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%BA%94%20%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2%3A%20ByteBuf%2FByteBuf%E8%AF%BB%E5%86%99%E6%8C%87%E9%92%88.png" alt="ByteBuf读写指针.png"></p>
<p>有如下性质：</p>
<ul>
<li>每读取一个字节，readerIndex递增1；直到readerIndex等于writerIndex，表示ByteBuf已经不可读；</li>
<li>每写入一个字节，writerIndex递增1；直到writerIndex等于capacity，表示ByteBuf已经不可写；</li>
<li>当writerIndex等于capacity表示底层字节数组需要扩容，且最大扩容不能超过max capacity。</li>
</ul>
<p>有如上性质，可以推出以下ByteBuf的一些方法实现：</p>
<ul>
<li>readableBytes()：可读字节数 –&gt; this.writerIndex - this.readerIndex</li>
<li>writableBytes()：可写字节数 –&gt; this.capacity - this.writerIndex</li>
<li>isReadable()：是否可读 –&gt; this.writerIndex - this.readerIndex &gt; 0</li>
<li>isWritable()：是否可写 –&gt; this.capacity - this.writerIndex &gt; 0</li>
</ul>
<p>更多方法见下。</p>
<h2 id="ByteBuf接口常用方法"><a href="#ByteBuf接口常用方法" class="headerlink" title="ByteBuf接口常用方法"></a>ByteBuf接口常用方法</h2><p>ByteBuf继承了Comparable和RefrenceCounted，其中后者是支持引用计数的接口，它的核心方法包含两个：</p>
<pre><code class="java">    // 引用数加1
    ReferenceCounted retain();
    // 引用数减1，如果引用数减为0，则释放该对象。
    // 如果该对象被释放则返回true，否则返回false。
    // 注意：子类实现其实是减2，后文会提到。
    boolean release();
</code></pre>
<p>再来看ByteBuf的核心方法：</p>
<ul>
<li>容量有关方法</li>
</ul>
<pre><code class="java">    // 1.返回当前容量
    public abstract int capacity();
    // 2.调整当前容量
    public abstract ByteBuf capacity(int newCapacity);
    // 3.最大容量（capacity的最大上限）
    public abstract int maxCapacity();
</code></pre>
<p>注意 capacity() &lt;&#x3D; maxCapacity()。</p>
<ul>
<li>读写指针有关方法</li>
</ul>
<pre><code class="java">    // 读写指针相关方法
    // 1.获取当前读指针
    public abstract int readerIndex();
    // 2.设置当前读指针
    public abstract ByteBuf readerIndex(int readerIndex);
    // 3.获取当前写指针
    public abstract int writerIndex();
    // 4.设置当前写指针
    public abstract ByteBuf writerIndex(int writerIndex);
    // 5.同时设置读写指针
    public abstract ByteBuf setIndex(int readerIndex, int writerIndex);
    // 6.获取可读字节数(this.writerIndex - this.readerIndex)
    public abstract int readableBytes();
    // 7.获取可写字节数(this.capacity - this.writerIndex)
    public abstract int writableBytes();
    // 8.获取最大可写字节数 (this.maxCapacity - this.writerIndex)&#125;
    public abstract int maxWritableBytes();
    // 9.是否可读(this.writerIndex - this.readerIndex)
    public abstract boolean isReadable();
    // 10.是否可写(this.capacity - this.writerIndex)
    public abstract boolean isWritable();
    // 11.清空(相当于setIndex(0, 0))
    public abstract ByteBuf clear();
    // 12.记录读指针
    public abstract ByteBuf markReaderIndex();
    // 13.从记录中恢复读指针
    public abstract ByteBuf resetReaderIndex();
    // 14.记录写指针 
    public abstract ByteBuf markWriterIndex();
    // 15.从记录中恢复写指针
    public abstract ByteBuf resetWriterIndex();
    // 16.丢弃已读字节
    public abstract ByteBuf discardReadBytes();
</code></pre>
<p>上述方法都是围绕着readerIndex、writerIndex、capital、maxcapital等四个值衍生的方法。实现都非常类似而简单。</p>
<ul>
<li>随机读写数据有关方法</li>
</ul>
<pre><code class="java">
    // 随机读写数据
    // ... 这部分类似的方法非常多，以下只列举一部分 ...
    // 1.从指定位置读取数据
    public abstract boolean getBoolean(int index);
    public abstract short getUnsignedByte(int index);
    public abstract short getShort(int index);
    public abstract int getUnsignedShort(int index);
    public abstract int   getInt(int index);
    public abstract long  getLong(int index);
    public abstract double getDouble(int index);
    public abstract short getShortLE(int index);（LE：Little Endian byte order，表示小端序，下同）
    public abstract int   getIntLE(int index);
    public abstract long  getLongLE(int index);
    // 略...
    // 2.在指定位置写入数据
    public abstract ByteBuf setBoolean(int index, boolean value);
    public abstract ByteBuf setByte(int index, int value);
    public abstract ByteBuf setShortLE(int index, int value);
    public abstract ByteBuf setInt(int index, int value);
    public abstract ByteBuf setIntLE(int index, int value);
    // 略... 
</code></pre>
<p>上述方法支持指定位置的读写数据，其中读数据并不会改变指针值。</p>
<ul>
<li>顺序读写数据有关方法。</li>
</ul>
<pre><code class="java">    // 1. 在readerIndex位置读取数据并移动指针
    public abstract boolean readBoolean();
    public abstract byte  readByte();
    public abstract short readShort();
    public abstract short readShortLE();
    public abstract int   readInt();
    public abstract int   readIntLE();
    // 略...
    // 2. 在位置写入数据并移动指针
    public abstract ByteBuf writeBoolean(boolean value);
    public abstract ByteBuf writeByte(int value);
    public abstract ByteBuf writeShort(int value);
    public abstract ByteBuf writeShortLE(int value);
    public abstract ByteBuf writeInt(int value);
    public abstract ByteBuf writeIntLE(int value);
    // 略...
</code></pre>
<p>上述方法从读(或写)指针位置顺序往后读(或写)数据，并移动读(或写)指针。</p>
<ul>
<li>分片相关方法</li>
</ul>
<pre><code class="java">    public abstract ByteBuf slice();
    public abstract ByteBuf slice(int index, int length);
    public abstract ByteBuf duplicate();
    public abstract ByteBuf retainedSlice(); // 更新引用计数
    public abstract ByteBuf retainedDuplicate(); // 更新引用计数
</code></pre>
<p>ByteBuf支持分片获取，实现快速的低成本浅复制。</p>
<ul>
<li>其他方法</li>
</ul>
<pre><code class="java">    // 判断底层是否为NIO direct buffer
    public abstract boolean isDirect();
</code></pre>
<h2 id="ByteBuf浅复制实现"><a href="#ByteBuf浅复制实现" class="headerlink" title="ByteBuf浅复制实现"></a>ByteBuf浅复制实现</h2><p>上一节我们提到了ByteBuf支持浅复制分片，其中分为slice浅复制和duplicate浅复制。duplicate与slice的区别是，duplicate是对整个ByteBuf的浅复制，而slice只是对ByteBuf中的一部分进行浅复制。</p>
<p>ByteBuf的浅复制分片其实就是与原来的ByteBuf共享同一个存储空间，并且也可以被多个分片同时共享。以slice(int index, int length)方法为例：</p>
<pre><code class="java">    // io.netty.buffer.AbstractByteBuf.java

    @Override
    public ByteBuf slice(int index, int length) &#123;
        ensureAccessible();
        return new UnpooledSlicedByteBuf(this, index, length);
    &#125;
</code></pre>
<p>slice方法内非常简单，只是新建了一个分片对象<em>UnpooledSlicedByteBuf</em>，构造函数传入了当前ByteBuf（this）、开始索引（index）以及分片长度（length）；</p>
<p>在父类的构造行数里，对该分片对象进行了初始化：</p>
<pre><code class="java">    // 被分片的ByteBuf
    private final ByteBuf buffer;
    // 偏移量
    private final int adjustment;

    AbstractUnpooledSlicedByteBuf(ByteBuf buffer, int index, int length) &#123;
        super(length);
        checkSliceOutOfBounds(index, length, buffer);
        if (buffer instanceof AbstractUnpooledSlicedByteBuf) &#123;
            // 如果传入的是slice分片，则需要叠加其偏移量
            this.buffer = ((AbstractUnpooledSlicedByteBuf) buffer).buffer;
            adjustment = ((AbstractUnpooledSlicedByteBuf) buffer).adjustment + index;
        &#125; else if (buffer instanceof DuplicatedByteBuf) &#123;
            // 如果传入的是dulicated分片，不需要叠加(因为其偏移量为0)
            this.buffer = buffer.unwrap();
            adjustment = index;
        &#125; else &#123;
            this.buffer = buffer;
            adjustment = index;
        &#125;
        // 初始化当前最大容量，对分片来说，最大容量不能超过length
        initLength(length);
        // 初始化写指针
        writerIndex(length);
    &#125;
</code></pre>
<p>可见，slice分片仅仅是对原ByteBuf进行了一层封装，并没有发生任何内存复制行为，所以是非常高效快捷的操作。</p>
<p>与slice类似，duplicate也是如此手法。唯一不同是，duplicate是对整个ByteBuf进行浅复制：</p>
<pre><code class="java">
    public DuplicatedByteBuf(ByteBuf buffer) &#123;
        this(buffer, buffer.readerIndex(), buffer.writerIndex());
    &#125;

    DuplicatedByteBuf(ByteBuf buffer, int readerIndex, int writerIndex) &#123;
        super(buffer.maxCapacity());

        if (buffer instanceof DuplicatedByteBuf) &#123;
            this.buffer = ((DuplicatedByteBuf) buffer).buffer;
        &#125; else if (buffer instanceof AbstractPooledDerivedByteBuf) &#123;
            this.buffer = buffer.unwrap();
        &#125; else &#123;
            this.buffer = buffer;
        &#125;
        // 直接复用原ByteBuf的读写指针
        setIndex(readerIndex, writerIndex);
        markReaderIndex();
        markWriterIndex();
    &#125;
</code></pre>
<p><strong>值得注意的是，无论是slice还是duplicate，都没有调用retain()方法来改变底层ByteBuf的引用计数。</strong> 所以，如果底层ByteBuf调用release()后被释放，那么所有基于该ByteBuf的浅复制对象都不能进行读写。所以要确保浅复制实例的使用安全，需要通过调用一次retain()方法来递增底层ByteBuf的引用计数；然后在浅复制实例使用结束后，再调用一次release()来递减底层ByteBuf的引用计数。</p>
<h2 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h2><p>CompositeByteBuf也是一个非常典型的ByteBuf，用来将多个ByteBuf组合在一起，形成一个逻辑上的ByteBuf。这点和分片ByteBuf非常类似，都属于在逻辑层面上避免拷贝，实现所谓的“零复制”（Zero Copy)。</p>
<p>CompositeByteBuf在内部维护一个可扩容的components数组，所有被组合的ByteBuf被封装为Component对象，对象中缓存了该ByteBuf的偏移量adjustment、开始索引offset、结束索引endOffset等。</p>
<pre><code class="java">    private Component[] components; // resized when needed

    private static final class Component &#123;
        final ByteBuf buf;
        int adjustment;
        int offset;
        int endOffset;

        private ByteBuf slice; // cached slice, may be null
    &#125;
</code></pre>
<p>对CompositeByteBuf的读写，需要先在components数组里二分查找对应索引所在的Component对象，然后对Component对象所包装的ByteBuf进行读写。如下：</p>
<pre><code class="java">    @Override
    protected byte _getByte(int index) &#123;
        // 确定索引index所在的Component对象
        Component c = findComponent0(index);
        // 对Component对象所包装的ByteBuf进行读写
        return c.buf.getByte(c.idx(index));
    &#125;

    private Component findComponent0(int offset) &#123;
        // 先检查最近访问的Component是否满足条件
        Component la = lastAccessed;
        if (la != null &amp;&amp; offset &gt;= la.offset &amp;&amp; offset &lt; la.endOffset) &#123;
           return la;
        &#125;
        // 否则二分查找
        return findIt(offset);
    &#125;

    // 二分查找
    private Component findIt(int offset) &#123;
        for (int low = 0, high = componentCount; low &lt;= high;) &#123;
            int mid = low + high &gt;&gt;&gt; 1;
            Component c = components[mid];
            if (offset &gt;= c.endOffset) &#123;
                low = mid + 1;
            &#125; else if (offset &lt; c.offset) &#123;
                high = mid - 1;
            &#125; else &#123;
                lastAccessed = c;
                return c;
            &#125;
        &#125;

        throw new Error(&quot;should not reach here&quot;);
    &#125;
</code></pre>
<p>CompositeByteBuf的核心思想大致如上，其他细节不作深究。</p>
<h2 id="ByteBuf引用计数实现"><a href="#ByteBuf引用计数实现" class="headerlink" title="ByteBuf引用计数实现"></a>ByteBuf引用计数实现</h2><h3 id="引用计数字段"><a href="#引用计数字段" class="headerlink" title="引用计数字段"></a>引用计数字段</h3><p>引用计数功能是在<em>AbstractReferenceCountedByteBuf</em>类中实现的。核心功能使用CAS原子操作和位运算实现。关键字段有两个：</p>
<pre><code class="java">    private static final AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater =
            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, &quot;refCnt&quot;);

    // even =&gt; &quot;real&quot; refcount is (refCnt &gt;&gt;&gt; 1); odd =&gt; &quot;real&quot; refcount is 0
    @SuppressWarnings(&quot;unused&quot;)
    private volatile int refCnt = 2;
</code></pre>
<p>refCntUpdater是修改refCnt字段的原子更新器。而refCnt是存储引用计数的字段。注意，当前ByteBuf的引用数为 refCnt &#x2F; 2，因此当refCnt等于1时，引用数为0。</p>
<h3 id="增加引用retain"><a href="#增加引用retain" class="headerlink" title="增加引用retain"></a>增加引用retain</h3><p>retain方法可以增加ByteBuf的引用计数。核心代码如下：</p>
<pre><code class="java">    @Override
    public ByteBuf retain() &#123;
        return retain0(1);
    &#125;

    private ByteBuf retain0(final int increment) &#123;
        // 将increment扩大两倍为adjustedIncrement
        int adjustedIncrement = increment &lt;&lt; 1; // 此处允许溢出，因为后边有判断溢出的逻辑
        // 将adjustedIncrement更新到refCnt，因此refCnt初始值为2，所以恒为偶数
        int oldRef = refCntUpdater.getAndAdd(this, adjustedIncrement);
        // 如果oldRef不是偶数，直接抛异常
        if ((oldRef &amp; 1) != 0) &#123;
            throw new IllegalReferenceCountException(0, increment);
        &#125;
        // 如果oldRef 和 oldRef + adjustedIncrement 正负异号，则意味着已经溢出。
        if ((oldRef &lt;= 0 &amp;&amp; oldRef + adjustedIncrement &gt;= 0)
                || (oldRef &gt;= 0 &amp;&amp; oldRef + adjustedIncrement &lt; oldRef)) &#123;
            // 发生溢出需要回滚adjustedIncrement
            refCntUpdater.getAndAdd(this, -adjustedIncrement);
            // 然后抛异常
            throw new IllegalReferenceCountException(realRefCnt(oldRef), increment);
        &#125;
        return this;
    &#125;
</code></pre>
<p>注释已经讲得很明白，这里再补充下：每次调用retain()，都会尝试给refCnt加2，所以确保了refCnt恒为偶数，也就是说当前引用数为refCnt &#x2F; 2。这里为啥设计为递增2而不是递增1，估计是位运算更加高效吧，而且实际应用中Integer.MAX_VALUE &#x2F; 2的引用数也是绰绰有余。</p>
<h3 id="释放引用release"><a href="#释放引用release" class="headerlink" title="释放引用release"></a>释放引用release</h3><p>恰恰相反，release()操作每次减少引用计数2，如下：</p>
<pre><code class="java">    @Override
    public boolean release() &#123;
        return release0(1);
    &#125;

    private boolean release0(int decrement) &#123;
        int rawCnt = nonVolatileRawCnt(), realCnt = toLiveRealCnt(rawCnt, decrement);
        if (decrement == realCnt) &#123;
            // 如果decrement == realCnt，意味着需要释放对象
            if (refCntUpdater.compareAndSet(this, rawCnt, 1)) &#123;
                deallocate();
                return true;
            &#125;
            return retryRelease0(decrement);
        &#125;
        return releaseNonFinal0(decrement, rawCnt, realCnt);
    &#125;

    private boolean releaseNonFinal0(int decrement, int rawCnt, int realCnt) &#123;
        if (decrement &lt; realCnt
                // all changes to the raw count are 2x the &quot;real&quot; change
                &amp;&amp; refCntUpdater.compareAndSet(this, rawCnt, rawCnt - (decrement &lt;&lt; 1))) &#123;
            return false;
        &#125;
        // 上述更新失败则调用重试方法
        return retryRelease0(decrement);
    &#125;

    private boolean retryRelease0(int decrement) &#123;
        // 死循环不断重试释放引用
        for (;;) &#123;
            int rawCnt = refCntUpdater.get(this), realCnt = toLiveRealCnt(rawCnt, decrement);
            if (decrement == realCnt) &#123;
                if (refCntUpdater.compareAndSet(this, rawCnt, 1)) &#123;
                    // 如果refCnt为1，意味着实际的引用数为1/2=0，所以需要释放掉
                    deallocate();
                    return true;
                &#125;
            &#125; else if (decrement &lt; realCnt) &#123;
                // 如果当前引用数realCnt大于decrement，则可以正常更新
                if (refCntUpdater.compareAndSet(this, rawCnt, rawCnt - (decrement &lt;&lt; 1))) &#123;
                    return false;
                &#125;
            &#125; else &#123;
                // 如果当前引用数realCnt小于decrement，则抛出引用异常
                throw new IllegalReferenceCountException(realCnt, -decrement);
            &#125;
            Thread.yield(); // this benefits throughput under high contention
        &#125;
    &#125;

    /**
     * Like &#123;@link #realRefCnt(int)&#125; but throws if refCnt == 0
     */
    private static int toLiveRealCnt(int rawCnt, int decrement) &#123;
        if ((rawCnt &amp; 1) == 0) &#123;
            // 如果是偶数，则引用数为rawCnt &gt;&gt;&gt; 1
            return rawCnt &gt;&gt;&gt; 1;
        &#125;
        // 如果是奇数，意味着该对象可能已经被释放掉
        throw new IllegalReferenceCountException(0, -decrement);
    &#125;
</code></pre>
<p><strong>release0算法流程：</strong></p>
<ul>
<li><ol>
<li>获取当前计数rawCnt，获取实际引用数realCnt；</li>
</ol>
</li>
<li><ol start="2">
<li>判断decrement是否等于realCnt；</li>
</ol>
</li>
<li><ul>
<li>2.1 如果相等，意味着本次release之后，对象需要被释放，尝试原子操作修改引用数；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>2.1.1 如果修改成功，直接释放对象并返回true；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>2.2.2 如果修改失败，调用retryRelease0进行循环重试释放；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>2.2 如果不相等，意味着本次release之后，对象依然存活，尝试调用releaseNonFinal0；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>2.2.1 如果decrement &lt; realCnt，且原子修改引用计数成功，直接返回false；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>2.2.2 否则，调用retryRelease0进行循环重试释放。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>retryRelease0算法流程：</strong></p>
<ul>
<li><ol>
<li>死循环开始；</li>
</ol>
</li>
<li><ol start="2">
<li>获取当前计数rawCnt，获取实际引用数realCnt；</li>
</ol>
</li>
<li><ol start="3">
<li>判断decrement &#x3D;&#x3D; realCnt；</li>
</ol>
</li>
<li><ul>
<li>3.1 如果相等，意味着本次release之后，对象需要被释放，尝试原子操作修改引用数；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>3.1.1 如果修改成功，直接释放对象并返回true；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>3.1.2 否则跳转6；</li>
</ul>
</li>
</ul>
</li>
<li><ol start="4">
<li>判断decrement &lt; realCnt；</li>
</ol>
</li>
<li><ul>
<li>4.1 如果成立，意味着本次release之后，对象依然存活，尝试原子更新引用计数；</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>4.1.1 如果修改成功，直接返回false；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>4.1.2 否则跳转6；</li>
</ul>
</li>
</ul>
</li>
<li><ol start="5">
<li>其他情况（decrement &gt; realCnt) 直接抛异常；</li>
</ol>
</li>
<li><ol start="6">
<li>Thread.yield()；</li>
</ol>
</li>
<li><ol start="7">
<li>跳转到1。</li>
</ol>
</li>
</ul>
<h2 id="池化和非池化"><a href="#池化和非池化" class="headerlink" title="池化和非池化"></a>池化和非池化</h2><p>我们看到ByteBuf分为两类池化(Pooled)和非池化(Unpooled)。非池化的ByteBuf每次新建都会申请新的内存空间，并且用完即弃，给JVM的垃圾回收带来负担；而池化的ByteBuf通过内部栈来保存闲置的对象空间，每次新建ByteBuf的时候，优先向内部栈申请闲置的对象空间，并且用完之后重新归还给内部栈，从而减少了JVM的垃圾回收压力。</p>
<h3 id="非池化实现"><a href="#非池化实现" class="headerlink" title="非池化实现"></a>非池化实现</h3><p>非池化的ByteBuf实现非常简单粗暴。下边分别以UnpooledHeapByteBuf和UnpooledDirectByteBuf为例：</p>
<ul>
<li>对象分配<br>UnpooledHeapByteBuf在构造函数里直接新建了一个字节数组来保存数据：</li>
</ul>
<pre><code class="java">    private final ByteBufAllocator alloc;
    // 使用字节数组保存数据
    byte[] array;

    public UnpooledHeapByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) &#123;
        super(maxCapacity);

        checkNotNull(alloc, &quot;alloc&quot;);

        if (initialCapacity &gt; maxCapacity) &#123;
            throw new IllegalArgumentException(String.format(
                    &quot;initialCapacity(%d) &gt; maxCapacity(%d)&quot;, initialCapacity, maxCapacity));
        &#125;

        this.alloc = alloc;
        setArray(allocateArray(initialCapacity));
        setIndex(0, 0);
    &#125;
    // 分配字节数组
    protected byte [] allocateArray(int initialCapacity) &#123;
        return new byte[initialCapacity];
    &#125;
</code></pre>
<p>而UnpooledDirectByteBuf则在构造函数中直接新建了一个DirectBuffer：</p>
<pre><code class="java">    // 使用DirectBuffer保存数据
    private ByteBuffer buffer;
    public UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) &#123;
        super(maxCapacity);
        if (alloc == null) &#123;
            throw new NullPointerException(&quot;alloc&quot;);
        &#125;
        if (initialCapacity &lt; 0) &#123;
            throw new IllegalArgumentException(&quot;initialCapacity: &quot; + initialCapacity);
        &#125;
        if (maxCapacity &lt; 0) &#123;
            throw new IllegalArgumentException(&quot;maxCapacity: &quot; + maxCapacity);
        &#125;
        if (initialCapacity &gt; maxCapacity) &#123;
            throw new IllegalArgumentException(String.format(
                    &quot;initialCapacity(%d) &gt; maxCapacity(%d)&quot;, initialCapacity, maxCapacity));
        &#125;

        this.alloc = alloc;
        setByteBuffer(allocateDirect(initialCapacity));
    &#125;
    // 分配DirectBuffer
    protected ByteBuffer allocateDirect(int initialCapacity) &#123;
        return ByteBuffer.allocateDirect(initialCapacity);
    &#125;
</code></pre>
<ul>
<li>对象释放<br>UnpooledHeapByteBuf的释放全权交给JVM：</li>
</ul>
<pre><code class="java">    @Override
    protected void deallocate() &#123;
        freeArray(array);
        array = EmptyArrays.EMPTY_BYTES;
    &#125;

    protected void freeArray(byte[] array) &#123;
        // NOOP
    &#125;
</code></pre>
<p>而UnpooledDirectByteBuf则尝试主动释放其拥有的DirectBuffer：</p>
<pre><code class="java">    @Override
    protected void deallocate() &#123;
        ByteBuffer buffer = this.buffer;
        if (buffer == null) &#123;
            return;
        &#125;

        this.buffer = null;

        if (!doNotFree) &#123;
            // 如果DirectBuffer还没被释放，则尝试释放之
            freeDirect(buffer);
        &#125;
    &#125;

    /**
     * Free a direct &#123;@link ByteBuffer&#125;
     */
    protected void freeDirect(ByteBuffer buffer) &#123;
        PlatformDependent.freeDirectBuffer(buffer);
    &#125;
</code></pre>
<h3 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h3><p>池化的ByteBuf都继承自PooledByteBuf<T>类，包括PooledHeapByteBuf、PooledDirectByteBuf、PooledUnsafeDirectByteBuf、PooledUnsafeHeapByteBuf。</p>
<p>这四个子类都持有一个回收器字段，例如，在PooledHeapByteBuf中有：</p>
<pre><code class="java">    private static final Recycler&lt;PooledHeapByteBuf&gt; RECYCLER = new Recycler&lt;PooledHeapByteBuf&gt;() &#123;
        @Override
        protected PooledHeapByteBuf newObject(Handle&lt;PooledHeapByteBuf&gt; handle) &#123;
            return new PooledHeapByteBuf(handle, 0);
        &#125;
    &#125;;
</code></pre>
<p>Recycler<T>是一个抽象类，所有的子类都要实现一个newObject方法，用于新建一个子类ByteBuf对象。</p>
<p>Recycler<T>本质上实现的是一个栈的功能，新建ByteBuf的时候，可以向Recycler<T>申请一个闲置对象；当ByteBuf使用完毕后，可以回收并归还给Recycler<T>。</p>
<ul>
<li><strong>申请ByteBuf</strong></li>
</ul>
<p>子类调用RECYCLER.get()来申请闲置对象，方法实现：</p>
<pre><code class="java">    public final T get() &#123;
        if (maxCapacityPerThread == 0) &#123;
            return newObject((Handle&lt;T&gt;) NOOP_HANDLE);
        &#125;
        // 尝试从栈中获取闲置对象
        Stack&lt;T&gt; stack = threadLocal.get();
        DefaultHandle&lt;T&gt; handle = stack.pop();
        if (handle == null) &#123;
            // 如果没有闲置对象，调用newObject新建一个新的对象。
            handle = stack.newHandle();
            handle.value = newObject(handle);
        &#125;
        return (T) handle.value;
    &#125;
</code></pre>
<p>可见，新建池化的ByteBuf都是优先从栈中获取闲置对象；当栈没有闲置对象再新建。值得注意的是，新建对象还传入了新建的handle，这个handle在对象回收阶段会使用到。</p>
<p>另外为了抹去历史的使用痕迹，每个新申请的ByteBuf对象，都会调用reuse方法进行初始化（以PooledDirectByteBuf为例）：</p>
<pre><code class="java">    static PooledDirectByteBuf newInstance(int maxCapacity) &#123;
        PooledDirectByteBuf buf = RECYCLER.get();
        buf.reuse(maxCapacity);
        return buf;
    &#125;
    /**
     * Method must be called before reuse this &#123;@link PooledByteBufAllocator&#125;
     */
    final void reuse(int maxCapacity) &#123;
        maxCapacity(maxCapacity);
        setRefCnt(1);
        setIndex0(0, 0);
        discardMarks();
    &#125;
</code></pre>
<ul>
<li><strong>回收ByteBuf</strong></li>
</ul>
<p>前面我们提到：当ByteBuf引用数为0的时候，会调用deallocate()方法进行释放。实现如下：</p>
<pre><code class="java">    @Override
    protected final void deallocate() &#123;
        if (handle &gt;= 0) &#123;
            final long handle = this.handle;
            this.handle = -1;
            memory = null;
            chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);
            tmpNioBuf = null;
            chunk = null;
            recycle();
        &#125;
    &#125;

    private void recycle() &#123;
        recyclerHandle.recycle(this);
    &#125;
</code></pre>
<p>如上，最后调用了handler进行回收。所谓的回收动作，其实就是放回栈中：</p>
<pre><code class="java">    static final class DefaultHandle&lt;T&gt; implements Handle&lt;T&gt; &#123;
        private int lastRecycledId;
        private int recycleId;

        boolean hasBeenRecycled;

        private Stack&lt;?&gt; stack;
        private Object value;

        DefaultHandle(Stack&lt;?&gt; stack) &#123;
            this.stack = stack;
        &#125;

        @Override
        public void recycle(Object object) &#123;
            if (object != value) &#123;
                throw new IllegalArgumentException(&quot;object does not belong to handle&quot;);
            &#125;

            Stack&lt;?&gt; stack = this.stack;
            if (lastRecycledId != recycleId || stack == null) &#123;
                throw new IllegalStateException(&quot;recycled already&quot;);
            &#125;
            // 将该handler重新放入栈中
            stack.push(this);
        &#125;
    &#125;
</code></pre>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><h3 id="Unsafe实现"><a href="#Unsafe实现" class="headerlink" title="Unsafe实现"></a>Unsafe实现</h3><p>还有一类使用了Unsafe操作的ByteBuf，例如：UnpooledUnsafeDirectByteBuf、UnpooledUnsafeHeapByteBuf、PooledUnsafeHeapByteBuf、PooledUnsafeDirectByteBuf。</p>
<p>这类ByteBuf的特点就是所有的读写操作都是用了sun.misc.Unsafe。如下：</p>
<pre><code class="java">    @Override
    protected byte _getByte(int index) &#123;
        return UnsafeByteBufUtil.getByte(addr(index));
    &#125;
</code></pre>
<p>而UnsafeByteBufUtil底层调用了sum.misc.Unsafe ：</p>
<pre><code class="java">    static byte getByte(long address) &#123;
        return UNSAFE.getByte(address);
    &#125;
</code></pre>
<p>而不是用Unsafe操作的ByteBuf，一般使用的是HeapByteBufUtil：</p>
<pre><code class="java">    @Override
    protected byte _getByte(int index) &#123;
        return HeapByteBufUtil.getByte(memory, idx(index));
    &#125;
</code></pre>
<p>而HeapByteBufUtil底层其实是简单的数组寻址：</p>
<pre><code class="java">    static byte getByte(byte[] memory, int index) &#123;
        return memory[index];
    &#125;
</code></pre>
<h3 id="Unsafe的性能提升"><a href="#Unsafe的性能提升" class="headerlink" title="Unsafe的性能提升"></a>Unsafe的性能提升</h3><p>Unsafe操作可以带来非常可观的性能提升，我写了一个简单的Benchmark测了下：</p>
<pre><code class="java">    @BenchmarkMode(&#123;Mode.Throughput&#125;)
    @Warmup(iterations = 1)
    @Measurement(iterations = 2, time = 1)
    @OutputTimeUnit(TimeUnit.SECONDS)
    @Fork(value = 2)
    @Threads(8)
    @State(Scope.Benchmark)
    @OperationsPerInvocation
    public class UnsafeBenchmark &#123;

        private static byte[] unsafeByteArray;

        private static byte[] safeByteArray;

        @Setup
        public void setup() &#123;
            unsafeByteArray = new byte[100];

            safeByteArray = new byte[100];
        &#125;

        @Benchmark
        public void unsafeMethod() &#123;
            int value = 1;
            UnsafeByteBufUtil.setByte(unsafeByteArray, 0, value);
            UnsafeByteBufUtil.getByte(unsafeByteArray, 0);

            long longValue = 100L;
            UnsafeByteBufUtil.setLong(unsafeByteArray, 0, longValue);
            UnsafeByteBufUtil.getLong(unsafeByteArray, 0);
        &#125;

        @Benchmark
        public void safeMethod() &#123;
            int value = 1;
            HeapByteBufUtil.setByte(safeByteArray, 0, value);
            HeapByteBufUtil.getByte(safeByteArray, 0);

            long longValue = 100L;
            HeapByteBufUtil.setLong(safeByteArray, 0, longValue);
            HeapByteBufUtil.getLong(safeByteArray, 0);
        &#125;

        public static void main(String[] args) throws RunnerException &#123;
            Options opt = new OptionsBuilder()
                    .include(UnsafeBenchmark.class.getSimpleName())
                    .build();

            new Runner(opt).run();
        &#125;
    &#125;
</code></pre>
<p>测试结果显示UnsafeByteBufUtil的性能非常优越：</p>
<pre><code class="bash">Benchmark                                Mode  Samples           Score            Error  Units
c.t.n.u.UnsafeBenchmark.safeMethod      thrpt        4   168827679.833 ±   71641561.636  ops/s
c.t.n.u.UnsafeBenchmark.unsafeMethod    thrpt        4  3141320463.164 ± 1204482723.948  ops/s
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了ByteBuf及其子类的实现原理，包括读写指针、常用方法、浅复制、引用计数、池化、Unsafe对象等实现原理。<br>通过上述深入分析，我们了解到ByteBuf在Netty中承担着运载数据的重要功能。如果将Netty比作一个完整的生物体，那么将ByteBuf比作血液，那就再恰当不过了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mycs2012/article/details/94591307">Netty ByteBuf（图解 ）之一</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/crazymakercircle/article/details/84205697">Netty ByteBuf（图解二）：API 图解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mycs2012/article/details/94591307">池化和非池化ByteBuf</a></li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 duval1024@gmail.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '0249fec24dcaf3532c31',
            clientSecret: '8ca1dd59f6b90d119d2206a05550f959dcc8e211',
            repo: 'baygeekarea_commet_area',
            owner: 'duval1024',
            admin: ['duval1024'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2024 Duval
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.png" class="alipay" title="扫码支持">
            <img src="/img/wechat.png" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #050505;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #050505;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #fbf4aB;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
