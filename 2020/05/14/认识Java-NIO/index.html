<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>认识 Java NIO | 湾区极客</title>
  <meta name="keywords" content=" NIO ">
  <meta name="description" content="认识 Java NIO | 湾区极客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="湾区极客——大湾区技术极客聚集地">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="https://bayareageek.cn/about/index.html">
<meta property="og:site_name" content="湾区极客">
<meta property="og:description" content="湾区极客——大湾区技术极客聚集地">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-02T10:14:39.000Z">
<meta property="article:modified_time" content="2024-03-02T10:15:55.401Z">
<meta property="article:author" content="湾区极客">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>湾区极客</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/duval1024"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/duvalyang"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:869296790@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=869296790&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(36)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Java">
            
            Java
            <small>(17)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Spring">
            
            Spring
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="读书笔记">
            
            读书笔记
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="总结">
            
            总结
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="ES">
            
            ES
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="36">
<input type="hidden" id="yelog_site_word_count" value="92.8k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://bayareageek.cn/">湾区极客</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>代码整洁之道</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>读书笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>垃圾回收器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>垃圾收集器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>类加载机制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>生产问题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>输入输出流</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>搜索</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>文件描述符</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>线程池</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>性能分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>源码分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CAS原理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ES</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JVM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Netty</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NIO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Reactor</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 ES "
           href="/2024/06/10/ES%E5%AD%A6%E4%B9%A03-%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"
           data-tag="ES"
           data-author="" >
            <span class="post-title" title="ES学习3-文档管理11">ES学习3-文档管理11</span>
            <span class="post-date" title="2024-06-10 21:55:22">2024/06/10</span>
        </a>
        
        
        <a  class="全部文章 ES "
           href="/2024/05/22/ES%E5%AD%A6%E4%B9%A02-%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86/"
           data-tag="ES"
           data-author="" >
            <span class="post-title" title="ES学习2-索引管理">ES学习2-索引管理</span>
            <span class="post-date" title="2024-05-22 08:28:20">2024/05/22</span>
        </a>
        
        
        <a  class="全部文章 ES "
           href="/2024/05/12/ES%E5%AD%A6%E4%B9%A01-%E8%AE%A4%E8%AF%86/"
           data-tag="搜索,ES"
           data-author="" >
            <span class="post-title" title="ES学习1-认识">ES学习1-认识</span>
            <span class="post-date" title="2024-05-12 15:54:55">2024/05/12</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/04/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-6-ZGC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (六) ZGC 垃圾收集器">Java 虚拟机原理 (六) ZGC 垃圾收集器</span>
            <span class="post-date" title="2021-04-08 14:39:45">2021/04/08</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2021/02/09/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-3-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%B7%E6%81%A9%E6%B3%95%E5%88%99/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(3) 应用开发过程中的海恩法则">生产问题(3) 应用开发过程中的海恩法则</span>
            <span class="post-date" title="2021-02-09 22:18:16">2021/02/09</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/02/07/%E6%B7%B1%E5%85%A5-MySQL-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入 MySQL (六) 常见问题汇总">深入 MySQL (六) 常见问题汇总</span>
            <span class="post-date" title="2021-02-07 14:21:01">2021/02/07</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/06/%E6%B7%B1%E5%85%A5-MySQL-5-%E9%94%81/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (五) 锁">深入 MySQL (五) 锁</span>
            <span class="post-date" title="2021-02-06 22:19:08">2021/02/06</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/05/%E6%B7%B1%E5%85%A5-MySQL-4-%E7%B4%A2%E5%BC%95/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (四) 索引">深入 MySQL (四) 索引</span>
            <span class="post-date" title="2021-02-05 22:17:16">2021/02/05</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/04/%E6%B7%B1%E5%85%A5-MySQL-3-%E4%BA%8B%E5%8A%A1/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (三) 事务">深入 MySQL (三) 事务</span>
            <span class="post-date" title="2021-02-04 22:20:54">2021/02/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/01/30/%E6%B7%B1%E5%85%A5-MySQL-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (二) 文件系统">深入 MySQL (二) 文件系统</span>
            <span class="post-date" title="2021-01-30 12:00:39">2021/01/30</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/01/29/%E6%B7%B1%E5%85%A5-MySQL-1-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (一) 体系结构">深入 MySQL (一) 体系结构</span>
            <span class="post-date" title="2021-01-29 22:50:38">2021/01/29</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/11/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-5-G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (五) G1垃圾收集器深入">Java 虚拟机原理 (五) G1垃圾收集器深入</span>
            <span class="post-date" title="2021-01-11 01:00:07">2021/01/11</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/10/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-4-G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%A5%E9%97%A8/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (四) G1垃圾收集器入门">Java 虚拟机原理 (四) G1垃圾收集器入门</span>
            <span class="post-date" title="2021-01-10 21:40:07">2021/01/10</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/09/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"
           data-tag="JVM,Java,垃圾收集器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (三) 垃圾收集">Java 虚拟机原理 (三) 垃圾收集</span>
            <span class="post-date" title="2021-01-09 22:50:07">2021/01/09</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-2-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E5%9B%9E%E6%94%B6/"
           data-tag="JVM,Java"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (二) 对象创建与回收">Java 虚拟机原理 (二) 对象创建与回收</span>
            <span class="post-date" title="2021-01-08 23:56:07">2021/01/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/07/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-1-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"
           data-tag="JVM,Java"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (一) 内存划分">Java 虚拟机原理 (一) 内存划分</span>
            <span class="post-date" title="2021-01-07 22:56:07">2021/01/07</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/28/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1-Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"
           data-tag="Java,类加载机制"
           data-author="" >
            <span class="post-title" title="一文彻底掌握 Java 类加载机制">一文彻底掌握 Java 类加载机制</span>
            <span class="post-date" title="2020-12-28 22:11:49">2020/12/28</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java-IO%E7%B1%BB%E5%BA%93/"
           data-tag="Java,IO"
           data-author="" >
            <span class="post-title" title="一文彻底掌握Java IO类库">一文彻底掌握Java IO类库</span>
            <span class="post-date" title="2020-12-23 22:57:44">2020/12/23</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"
           data-tag="Java,文件描述符,输入输出流"
           data-author="" >
            <span class="post-title" title="深入理解Java文件输入输出流和文件描述符">深入理解Java文件输入输出流和文件描述符</span>
            <span class="post-date" title="2020-12-16 22:03:33">2020/12/16</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2020/12/15/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-2-ExceptionInInitializerError%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E8%A2%AB%E5%90%9E/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(2) ExceptionInInitializerError导致线程池中的线程异常被吞">生产问题(2) ExceptionInInitializerError导致线程池中的线程异常被吞</span>
            <span class="post-date" title="2020-12-15 17:26:29">2020/12/15</span>
        </a>
        
        
        <a  class="全部文章 读书笔记 "
           href="/2020/11/14/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"
           data-tag="读书笔记,代码整洁之道"
           data-author="" >
            <span class="post-title" title="《代码整洁之道》">《代码整洁之道》</span>
            <span class="post-date" title="2020-11-14 17:01:02">2020/11/14</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/10/26/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%89-%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之三 常用扩展点">再读Spring源码之三 常用扩展点</span>
            <span class="post-date" title="2020-10-26 18:31:25">2020/10/26</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/10/07/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BA%8C-FactoryBean/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之二 FactoryBean">再读Spring源码之二 FactoryBean</span>
            <span class="post-date" title="2020-10-07 21:00:39">2020/10/07</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/08/21/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%80-Spring%E5%A6%82%E4%BD%95%E5%AF%B9%E4%BB%98%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之一 Spring如何对付循环引用">再读Spring源码之一 Spring如何对付循环引用</span>
            <span class="post-date" title="2020-08-21 20:59:52">2020/08/21</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/15/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%85%AD-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8-Handler/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 六 流水线处理器: Handler">Netty 源码分析之 六 流水线处理器: Handler</span>
            <span class="post-date" title="2020-07-15 22:15:35">2020/07/15</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/09/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E4%BA%94-%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2-ByteBuf/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 五 奔腾的血液: ByteBuf">Netty 源码分析之 五 奔腾的血液: ByteBuf</span>
            <span class="post-date" title="2020-07-09 23:30:20">2020/07/09</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/04/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%9B%9B-Promise-%E4%B8%8E-Future-%E5%8F%8C%E5%AD%90%E6%98%9F%E7%9A%84%E7%A7%98%E5%AF%86/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 四 Promise 与 Future: 双子星的秘密">Netty 源码分析之 四 Promise 与 Future: 双子星的秘密</span>
            <span class="post-date" title="2020-07-04 16:10:56">2020/07/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/06/12/Java%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Reactor%E6%A8%A1%E5%9E%8B/"
           data-tag="NIO,Reactor"
           data-author="" >
            <span class="post-title" title="Java高性能网络编程--Reactor模型">Java高性能网络编程--Reactor模型</span>
            <span class="post-date" title="2020-06-12 14:48:28">2020/06/12</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/05/14/%E8%AE%A4%E8%AF%86Java-NIO/"
           data-tag="NIO"
           data-author="" >
            <span class="post-title" title="认识 Java NIO">认识 Java NIO</span>
            <span class="post-date" title="2020-05-14 15:27:54">2020/05/14</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2020/02/11/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-1-Java%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(1) Java进程CPU占用过高">生产问题(1) Java进程CPU占用过高</span>
            <span class="post-date" title="2020-02-11 21:49:14">2020/02/11</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/01/05/%E6%B7%B1%E5%85%A5JAVA%E8%AF%AD%E8%A8%80%E2%80%94CAS%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"
           data-tag="CAS原理"
           data-author="" >
            <span class="post-title" title="深入JAVA语言—CAS原理剖析">深入JAVA语言—CAS原理剖析</span>
            <span class="post-date" title="2020-01-05 18:16:26">2020/01/05</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/10/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903-%E5%AF%B9Bean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析3-对Bean循环依赖的处理">Spring源码分析3-对Bean循环依赖的处理</span>
            <span class="post-date" title="2018-10-12 15:47:01">2018/10/12</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-RESTful%20Web%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析1-RESTfulWeb启动过程">Spring源码分析1-RESTfulWeb启动过程</span>
            <span class="post-date" title="2018-07-12 11:47:01">2018/07/12</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%B7%E6%96%B0%E8%BF%87%E7%A8%8B/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析2-上下文刷新过程分析">Spring源码分析2-上下文刷新过程分析</span>
            <span class="post-date" title="2018-07-12 11:47:01">2018/07/12</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2017/08/10/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"
           data-tag="线程池"
           data-author="" >
            <span class="post-title" title="Java 线程池详解">Java 线程池详解</span>
            <span class="post-date" title="2017-08-10 16:47:18">2017/08/10</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2017/06/18/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"
           data-tag="JVM,性能分析"
           data-author="" >
            <span class="post-title" title="JVM性能监控工具总结">JVM性能监控工具总结</span>
            <span class="post-date" title="2017-06-18 16:47:54">2017/06/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-认识Java-NIO" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">认识 Java NIO</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java">Java</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color4">NIO</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-02-18 21:17:51'>2020-05-14 15:27</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:4.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO"><span class="toc-text">同步阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO"><span class="toc-text">Java NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO"><span class="toc-text">Java 多路复用IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-AIO"><span class="toc-text">Java AIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer"><span class="toc-text">Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E4%BD%BF%E7%94%A8"><span class="toc-text">Buffer使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">Buffer底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E5%B8%B8%E7%94%A8API"><span class="toc-text">Buffer常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flip-%E5%86%99-%E8%AF%BB"><span class="toc-text">flip 写-&gt;读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clear-%E8%AF%BB-%E5%86%99-%E8%AF%BB"><span class="toc-text">clear 读,写 -&gt; 读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compact-%E8%AF%BB-%E5%86%99"><span class="toc-text">compact 读 -&gt; 写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rewind"><span class="toc-text">rewind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mark-reset"><span class="toc-text">mark &amp;&amp; reset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">Buffer的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel"><span class="toc-text">FileChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DatagramChannel"><span class="toc-text">DatagramChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerSocketChannel"><span class="toc-text">ServerSocketChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel"><span class="toc-text">SocketChannel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selector"><span class="toc-text">Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KQueueSelectorImpl"><span class="toc-text">KQueueSelectorImpl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectionKey"><span class="toc-text">SelectionKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86Channel%E6%B3%A8%E5%86%8C%E5%88%B0Selector"><span class="toc-text">将Channel注册到Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B"><span class="toc-text">Selector使用样例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sever%E7%AB%AF"><span class="toc-text">Sever端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client%E7%AB%AF"><span class="toc-text">Client端</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java支持三种IO模式，分别是同步阻塞IO（BIO）、同步非阻塞IO（NIO)、多路复用IO（I&#x2F;O multiplexing）以及异步IO(AIO)。本文第一章节将简单介绍这三种IO模式，后续章节将详细介绍同步非阻塞IO（NIO）以及多路复用IO。</p>
<p>(首页图是蔚来NIO图，侵权必删。&#x3D; &#x3D;! )</p>
<span id="more"></span>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p>传统的IO是同步阻塞型IO（BIO）。阻塞型IO主要问题是会造成大量的系统资源浪费。例如我们通过Socket读取一个TCP连接的数据，当没有读取到数据时，read方法会阻塞当前线程。如下：</p>
<p>服务端socket读取数据将阻塞线程：</p>
<pre><code class="java">ServerSocket serverSocket = bind(listenIp, listenPort);
while (true) &#123;
    // 阻塞等待数据到来
    Socket socket = serverSocket.accept();
    // 新建线程来处理该socket数据
    executorService.execute(() -&gt; &#123;
        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        // 读取socket中的数据，如无数据将发生阻塞
        while (StringUtils.isNotBlank(str = br.readLine()))&#123;
            //doSomething
        &#125;
    &#125;
&#125;
</code></pre>
<p>客户端读取数据同样会阻塞线程：</p>
<pre><code class="java">this.socket = new Socket(this.host, this.port);
this.is = socket.getInputStream();
// 阻塞读取
this.is.read();
</code></pre>
<p>如果服务端接受了大量客户端请求，很有可能使得大量的线程阻塞而占用大量机器资源，甚至使得服务器崩溃。</p>
<p>除此之外，传统IO是基于字节流的，用户只能顺序地从流中读取数据，且不能随意改变读取指针。</p>
<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>Java NIO是同步非阻塞型IO。NIO引入了Channel和Buffer这两个概念，用户可以从Channel中读取Buffer，也可以将Buffer写入Channel。<br>实现了AbstractSelectableChannel父类的Channel，可以通过configureBlocking方法可以将一个Channel设置为非阻塞模式，如下：</p>
<pre><code class="java">serverSocketChannel.configureBlocking(false);
</code></pre>
<h3 id="Java-多路复用IO"><a href="#Java-多路复用IO" class="headerlink" title="Java 多路复用IO"></a>Java 多路复用IO</h3><p>我在这里将多路复用IO从上一小节剥离出来，是想让大家区分同步非阻塞型IO和多路复用IO的区别。</p>
<p>基于Java NIO的同步非阻塞IO，再结合Java NIO提供的Selector多路复用选择器，Java可以实现多路复用IO。NIO通过将Chanel注册进Selector中，由Selector来监听多个Channel的IO事件，从而避免单个Channel的读写阻塞导致整个线程挂起的情况。这样子，NIO就可以通过一个线程同时高效地管理多个Channel。</p>
<p>Selector的底层使用了底层系统调用，包括epoll、select等等，在主流的各个系统都有支持。但这部分内容不在本文的探讨范围之内。</p>
<h3 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h3><p>AIO在Java中不常用，可以参考大咖写的 <a target="_blank" rel="noopener" href="https://colobu.com/2014/11/13/java-aio-introduction/">Java AIO编程</a></p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer在NIO中作为数据的载体，用户可以从Channel中读取Buffer，也可以将Buffer写入Channel。</p>
<p>Buffer根据数据类型划分为ByteBuffer、ShortBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer等类型。这些Buffer都包含了两个子类实现，一个是DirectBuffer，另外一个是HeapBuffer。</p>
<p>其中以ByteBuffer类型为例，继承关系图如下所示：</p>
<p><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E4%BA%86%E8%A7%A3Java%20NIO%2FByteBuffer.png" alt="ByteBuffer.png"></p>
<h3 id="Buffer使用"><a href="#Buffer使用" class="headerlink" title="Buffer使用"></a>Buffer使用</h3><p>Buffer使用步骤非常简单：</p>
<ul>
<li>初始化指定容量大小，并分配directBuffer或heapBuffer；</li>
<li>初始化后Buffer默认为写模式，用户可以向Buffer中写入数据；</li>
<li>用户写入完成后，调用flip()方法之后可以切换到读模式；</li>
<li>Buffer处于读模式下，用户可以读取数据；</li>
<li>数据读取完毕后，用户可以调用clear()进行清理，或者调用compact()进行压缩。</li>
</ul>
<p>使用样例如下:</p>
<pre><code class="java">public static void main(String[] args) &#123;
    //ByteBuffer byteBuffer = ByteBuffer.allocateDirect(9); // direct buffer
    ByteBuffer byteBuffer = ByteBuffer.allocate(9);
    byteBuffer.put(&quot;hello&quot;.getBytes());
    byteBuffer.put(&quot; &quot;.getBytes());
    byteBuffer.put(&quot;NIO&quot;.getBytes());
    // 写模式切换到读模式
    byteBuffer.flip();

    byte[] content = new byte[9];
    byteBuffer.get(content);
    System.out.println(new String(content));
&#125;
</code></pre>
<h3 id="Buffer底层实现"><a href="#Buffer底层实现" class="headerlink" title="Buffer底层实现"></a>Buffer底层实现</h3><p>Buffer抽象类里有四个关键字段，他们的大小关系为：mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity，分别含义是：</p>
<ul>
<li><strong>mark</strong> 调用mark()时候会缓存position的值，等待调用reset()时候恢复使用，默认值为-1；</li>
<li><strong>postition</strong> 当前的读指针或者写指针所在位置；</li>
<li><strong>limit</strong> 写模式下等于capacity，而读模式写对应的是写模式下的position；</li>
<li><strong>capacity</strong> 最大容量，与buffer所处的模式无关。</li>
</ul>
<p>测试样例如下：</p>
<pre><code>@Test
public void test() &#123;
    IntBuffer intBuffer = IntBuffer.allocate(10);
    LOG.info(&quot;position=&#123;&#125;, limit=&#123;&#125;, capacity=&#123;&#125;&quot;, intBuffer.position(), intBuffer.limit(), intBuffer.capacity());
    intBuffer.put(0);
    intBuffer.put(1);
    LOG.info(&quot;position=&#123;&#125;, limit=&#123;&#125;, capacity=&#123;&#125;&quot;, intBuffer.position(), intBuffer.limit(), intBuffer.capacity());
    intBuffer.flip();
    LOG.info(&quot;position=&#123;&#125;, limit=&#123;&#125;, capacity=&#123;&#125;&quot;, intBuffer.position(), intBuffer.limit(), intBuffer.capacity());
    intBuffer.get();
    LOG.info(&quot;position=&#123;&#125;, limit=&#123;&#125;, capacity=&#123;&#125;&quot;, intBuffer.position(), intBuffer.limit(), intBuffer.capacity());
&#125;
</code></pre>
<pre><code>2020-05-15 16:32:20.934 [main] INFO  [IntBufferTest:18] - position=0, limit=10, capacity=10
2020-05-15 16:32:20.944 [main] INFO  [IntBufferTest:21] - position=2, limit=10, capacity=10
2020-05-15 16:32:20.944 [main] INFO  [IntBufferTest:23] - position=0, limit=2, capacity=10
2020-05-15 16:32:20.945 [main] INFO  [IntBufferTest:25] - position=1, limit=2, capacity=10
</code></pre>
<h3 id="Buffer常用API"><a href="#Buffer常用API" class="headerlink" title="Buffer常用API"></a>Buffer常用API</h3><h4 id="flip-写-读"><a href="#flip-写-读" class="headerlink" title="flip 写-&gt;读"></a>flip 写-&gt;读</h4><p>flip方法可以将buffer从写模式切换到读模式。原理很简单，就是将limit置为当前position，且position置0。</p>
<pre><code class="java">public final Buffer flip() &#123;
    limit = position;
    position = 0;
    mark = -1;
    return this;
&#125;
</code></pre>
<h4 id="clear-读-写-读"><a href="#clear-读-写-读" class="headerlink" title="clear 读,写 -&gt; 读"></a>clear 读,写 -&gt; 读</h4><p>clear方法不管buffer是读或写状态，都会清空buffer，重新恢复为初始写状态。但需要注意clear并<strong>没有清空原有数据</strong>，仅仅是修改了指针位置。依然可以读取到老的数据。</p>
<pre><code class="java">public final Buffer clear() &#123;
    position = 0;
    limit = capacity;
    mark = -1;
    return this;
&#125;
</code></pre>
<h4 id="compact-读-写"><a href="#compact-读-写" class="headerlink" title="compact 读 -&gt; 写"></a>compact 读 -&gt; 写</h4><p>该方法是Buffer子类里的方法，用于在读模式下压缩空间，将还没读到的数据复制到缓存数组开头，也就是从[position, limit)复制到[0, limit-position)。注意compact仅限于读模式下调用，调用之后buffer切换为写模式。以HeapIntBuffer为例：</p>
<pre><code class="java">public IntBuffer compact() &#123;
    // 复制[position, limit)到[0, limit-position)
    System.arraycopy(hb, ix(position()), hb, ix(0), remaining());
    // position置为limit-position，也就是写指针所在位置
    position(remaining());
    // 写模式下limit等于capacity
    limit(capacity());
    // 丢弃mark状态
    discardMark();
    return this;
&#125;
</code></pre>
<h4 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h4><p>很容易将clear和revind混淆，其实看看源码就知道区别：</p>
<pre><code class="java">public final Buffer rewind() &#123;
    position = 0;
    mark = -1;
    return this;
&#125;
</code></pre>
<p>由上可见，rewind没有修改limit，也就是没有切换buffer的读写模式，单纯是将position置为0。如果是读模式，相当于将读过的数据，重新从指针0开始再读一遍；如果是写模式，则是忽略已经写过的数据，从指针0位置重新开始写。</p>
<h4 id="mark-reset"><a href="#mark-reset" class="headerlink" title="mark &amp;&amp; reset"></a>mark &amp;&amp; reset</h4><p>mark方法可以缓存当前的position指针，而reset方法则是将position恢复为之前mark所缓存的值。</p>
<p>注意上边提及的所有方法都可以丢弃mark缓存，也就是说mark &amp;&amp; reset只有在读模式或者写模式写才能有效。例如：</p>
<pre><code class="java">@Test
public void testMark() &#123;
    IntBuffer intBuffer = IntBuffer.allocate(10);
    intBuffer.put(0);
    intBuffer.put(1);
    LOG.info(&quot;buffer=&#123;&#125;&quot;, intBuffer);
    intBuffer.mark();
    intBuffer.put(2);
    intBuffer.put(3);
    intBuffer.reset();
    LOG.info(&quot;buffer=&#123;&#125;&quot;, intBuffer);
&#125;
</code></pre>
<pre><code class="bash">2020-05-15 18:04:23.873 [main] INFO  [IntBufferTest:60] - buffer=java.nio.HeapIntBuffer[pos=2 lim=10 cap=10]
2020-05-15 18:04:23.880 [main] INFO  [IntBufferTest:65] - buffer=java.nio.HeapIntBuffer[pos=2 lim=10 cap=10]
</code></pre>
<p>如图调用reset方法后，position重新恢复为mark所缓存的值。这时候继续写入数据的话，就会覆盖掉数值2和3。</p>
<h3 id="Buffer的比较"><a href="#Buffer的比较" class="headerlink" title="Buffer的比较"></a>Buffer的比较</h3><p>以IntBuffer为例子，请见源码：</p>
<pre><code class="java">public int compareTo(IntBuffer that) &#123;
    int n = this.position() + Math.min(this.remaining(), that.remaining());
    for (int i = this.position(), j = that.position(); i &lt; n; i++, j++) &#123;
        int cmp = compare(this.get(i), that.get(j));
        if (cmp != 0)
            return cmp;
    &#125;
    return this.remaining() - that.remaining();
&#125;
</code></pre>
<p>从源码可以看出两个buffer的比较其实只是对剩余未读的数据进行对比。换言之，只有处于读模式的buffer进行比较才会有意义。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>channel在NIO中作为数据流的通道。常用几个Channel子类包括：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等。继承关系如下：</p>
<p><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E4%BA%86%E8%A7%A3Java%20NIO%2Fchannel%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="channel继承关系.png"></p>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>常用API：</p>
<ul>
<li><strong>open(Path path, OpenOption… options)</strong> 打开文件，可以通过options指定文件的打开参数（读写模式等）；</li>
<li><strong>read(ByteBuffer dst)</strong> 从channel中读取数据，并写入ByteBuffer中；</li>
<li><strong>write(ByteBuffer src)</strong> 读取ByteBuffer中的数据，并写入channel中；</li>
<li><strong>position(long newPosition)</strong> 设置channel的position；</li>
<li><strong>force(boolean metaData)</strong> 强制使得文件的所有变更落盘。metaData为true表示文件元数据变更也落盘，否则仅文件内容变更落盘；</li>
<li><strong>transferTo(long position, long count,WritableByteChannel target)</strong> 将该fileChannel内容写入目标channel中；</li>
<li><strong>truncate(long size)</strong> 将该channel截取为若干字节。</li>
</ul>
<p>使用样例：</p>
<pre><code class="java">     @Test
    public void testInputFromFileChannel() &#123;
        FileChannel fileChannel = null;
        try &#123;
            fileChannel = FileChannel.open(new File(&quot;/Users/duval/input.txt&quot;).toPath(), StandardOpenOption.READ);
            ByteBuffer readBuffer = ByteBuffer.allocate(100);
            StringBuilder fileContent = new StringBuilder();
            while (fileChannel.read(readBuffer) != -1) &#123;
                readBuffer.flip();
                fileContent.append(new String(readBuffer.array()));
                readBuffer.clear();
            &#125;
            System.out.println(fileContent.toString());
        &#125; catch (IOException e) &#123;
            LOG.error(&quot;read failed&quot;, e);
        &#125; finally &#123;
            IOUtils.closeQuietly(fileChannel);
        &#125;
    &#125;

    @Test
    public void testOutputToFileChannel() &#123;
        FileChannel fileChannel = null;
        try &#123;
            fileChannel =  FileChannel.open(new File(&quot;/Users/duval/output.txt&quot;).toPath(), StandardOpenOption.WRITE, StandardOpenOption.CREATE);
            ByteBuffer writeBuffer = ByteBuffer.allocate(1000);
            writeBuffer.put(&quot;hello nio&quot;.getBytes());
            writeBuffer.flip();
            while (writeBuffer.hasRemaining()) &#123;
                fileChannel.write(writeBuffer);
            &#125;
            // 强制数据落盘
            fileChannel.force(true);
        &#125; catch (IOException e) &#123;
            LOG.error(&quot;write failed&quot;, e);
        &#125; finally &#123;
            IOUtils.closeQuietly(fileChannel);
        &#125;
    &#125;
</code></pre>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>DatagramChannel可以用来实现UDP通讯。常用的API如下:</p>
<ul>
<li><strong>DatagramChannel open()</strong> 打开一个新的channel；</li>
<li><strong>DatagramChannel bind(SocketAddress local)</strong> 将该channel绑定到某个地址上（ip+端口）；</li>
<li><strong>SocketAddress receive(java.nio.ByteBuffer dst)</strong> 接收数据；</li>
<li><strong>int send(java.nio.ByteBuffer src, java.net.SocketAddress target)</strong> 发送数据；</li>
</ul>
<p>使用样例：</p>
<pre><code class="java">// UdpServer.java
/**
 * @author duval
 * @date 2020-05-17 20:17
 */
@Slf4j
public class UdpServer extends Thread &#123;

    private DatagramChannel channel;

    public UdpServer() throws IOException &#123;
        this.channel = DatagramChannel.open();
        this.channel.bind(new InetSocketAddress(&quot;localhost&quot;, 8080));
    &#125;

    @Override
    public void run() &#123;
        int num = 0;
        while (true) &#123;
            SocketAddress address;
            ByteBuffer byteBuffer = ByteBuffer.allocate(15);
            try &#123;
                address = channel.receive(byteBuffer);

                if (address != null &amp;&amp; byteBuffer.hasRemaining()) &#123;
                    byte[] array = new byte[byteBuffer.position()];
                    byteBuffer.flip();
                    byteBuffer.get(array);
                    byteBuffer.clear();
                    log.info(&quot;reveive:&#123;&#125;&quot;, new String(array));

                    response(address, num++);
                &#125;
            &#125; catch (IOException e) &#123;
                log.error(&quot;receive failed&quot;, e);
            &#125;
        &#125;
    &#125;

    private void response(SocketAddress address, int num) throws IOException &#123;
        ByteBuffer content = ByteBuffer.allocate(15);
        content.put((&quot;resp &quot; + num).getBytes());
        content.flip();
        channel.send(content, address);
    &#125;

    public static void main(String args[]) throws IOException, InterruptedException &#123;
        UdpServer server = new UdpServer();
        server.start();
        server.join();
    &#125;
&#125;
</code></pre>
<pre><code class="java">// UdpClient.java
@Slf4j
public class UdpClient extends Thread &#123;

    private DatagramChannel channel;

    public UdpClient() throws IOException &#123;
        this.channel = DatagramChannel.open();
    &#125;

    @Override
    public void run() &#123;
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                while (true) &#123;
                    SocketAddress address;
                    ByteBuffer dataBuffer = ByteBuffer.allocate(15);
                    try &#123;
                        address = channel.receive(dataBuffer);

                        if (address != null &amp;&amp; dataBuffer.hasRemaining()) &#123;
                            byte [] array = new byte[dataBuffer.position()];
                            dataBuffer.flip();
                            dataBuffer.get(array);
                            dataBuffer.clear();
                            log.info(&quot;reveive:&#123;&#125;&quot;, new String(array));
                        &#125;
                    &#125; catch (IOException e) &#123;
                        log.error(&quot;receive failed&quot;, e);
                    &#125;
                &#125;
            &#125;
        &#125;).start();

        Scanner scanner = new Scanner(System.in);
        while (true) &#123;
            String inputData =  scanner.nextLine();
            if (inputData.length() &gt; 10) &#123;
                log.error(&quot;too long&quot;);
                continue;
            &#125;
            ByteBuffer dataBuffer = ByteBuffer.allocate(15);
            dataBuffer.put(inputData.getBytes());
            dataBuffer.flip();
            try &#123;
                channel.send(dataBuffer, new InetSocketAddress(&quot;localhost&quot;, 8080));
            &#125; catch (IOException e) &#123;
                log.error(&quot;send failed&quot;, e);
            &#125;
        &#125;
    &#125;

    public static void main(String args[]) throws IOException, InterruptedException &#123;
        UdpClient client = new UdpClient();
        client.run();
        client.join();
    &#125;
&#125;
</code></pre>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>ServerSocketChannel用于TCP连接的服务器端。常用的API如下所示：</p>
<ul>
<li>打开Channel、关闭Channel</li>
</ul>
<pre><code class="java">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.close();
</code></pre>
<ul>
<li>绑定监听地址端口</li>
</ul>
<pre><code class="java">serverSocketChannel.socket().bind(new InetSocketAddress(8080));
</code></pre>
<ul>
<li>等待客户度连接</li>
</ul>
<pre><code class="java">SocketChannel clientChannel = serverSocketChannel.accept();
</code></pre>
<ul>
<li>指定阻塞或非阻塞</li>
</ul>
<pre><code class="java">serverSocketChannel.configureBlocking(false);
</code></pre>
<p>ServerSocketChannel初始化后默认是阻塞模式。比方说在阻塞模式下调用accept()方法后会阻塞进程等待直到有新的客户端连接到来，而在非阻塞模式下调用accept()方法不会发生阻塞而立即返回客户端socket（没有客户端连接时候返回null）。</p>
<ul>
<li>将channel注册到selector中</li>
</ul>
<pre><code class="java">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
</code></pre>
<p>Selector是NIO里核心组件，下一个章节将会详细介绍。当channel处于非阻塞模式，可以被注册到Selector中，由Selector代理接收所有的IO事件。</p>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>与ServerSocketChannel对应，SocketChannel适用于TCP连接的客户端。常用API如下：</p>
<ul>
<li>打开关闭Channel</li>
</ul>
<pre><code class="java">SocketChannel sc = SocketChannel.open();
sc.close();
</code></pre>
<ul>
<li>连接服务器</li>
</ul>
<pre><code class="java">sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
</code></pre>
<ul>
<li>指定阻塞或非阻塞</li>
</ul>
<pre><code class="java">sc.configureBlocking(false);
</code></pre>
<ul>
<li>注册到Selector</li>
</ul>
<pre><code class="java">sc.register(selector, SelectionKey.OP_CONNECT);
</code></pre>
<ul>
<li>读写数据</li>
</ul>
<pre><code>sc.write(writeBuffer);
sc.read(readBuffer);
</code></pre>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector是NIO实现IO多路复用模型的重要组件。多个Channel可以被注册到同一个Selector上，然后Selector会不断的轮询注册在它上面的Channel。一旦某个Channel有了新的IO事件就会被筛选出来进一步处理。因此，只需要一个线程负责Selector的轮询，就能够支撑大量的连接，从而能够支撑高并发服务的开发。基于Selector实现的IO多路复用模型示意图如下：</p>
<p><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E4%BA%86%E8%A7%A3Java%20NIO%2FIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt="IO多路复用模型.png"></p>
<h3 id="KQueueSelectorImpl"><a href="#KQueueSelectorImpl" class="headerlink" title="KQueueSelectorImpl"></a>KQueueSelectorImpl</h3><p>在MacOS下，Selector的默认实现是KQueueSelectorImpl，可以在JDK8源码下找到：openjdk-jdk8u-jdk8u&#x2F;jdk&#x2F;src&#x2F;macosx&#x2F;classes&#x2F;sun&#x2F;nio&#x2F;ch&#x2F;KQueueSelectorImpl.java</p>
<p>KQueueSelectorImpl继承关系如下：<br><img src="https://pic-bed-sz.oss-cn-shenzhen.aliyuncs.com/blog%2F%E4%BA%86%E8%A7%A3Java%20NIO%2FKQueueSelectorImpl.jpg" alt="KQueueSelectorImpl.jpg"></p>
<p>而在Linux 2.6+内核下，Selector的默认实现是是EPollSelectorImpl，源码在中：openjdk-jdk8u-jdk8u&#x2F;jdk&#x2F;src&#x2F;solaris&#x2F;classes&#x2F;sun&#x2F;nio&#x2F;ch&#x2F;EPollSelectorImpl.java</p>
<p>我们从父类SelectorImpl里可以看到两个字段：</p>
<pre><code class="java">    // The set of keys with data ready for an operation
    protected Set&lt;SelectionKey&gt; selectedKeys;

    // The set of keys registered with this Selector
    protected HashSet&lt;SelectionKey&gt; keys;
</code></pre>
<p>selectedKeys保存的是有新IO事件等待处理的Key；而keys保存的是所有的被注册到该Selector的key。</p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>上文提到SelectionKey，这究竟为何物，我们一起来探讨下。先看看常用的API：</p>
<ul>
<li><strong>public final Object attachment()</strong> 获取该SelectionKey的附加物。attachment常常用来附加数据。</li>
<li><strong>public abstract int interestOps()</strong> 获取感兴趣事件集合。Channel在注册时候可以指定感兴趣的事件。这里返回int，因为用位来表示事件。</li>
<li><strong>public abstract int readyOps()</strong> 获取已经就绪的事件集合。这里返回int，因为用位来表示事件。</li>
<li><strong>public abstract SelectableChannel channel()</strong> 返回该key关联的channel实例。</li>
<li><strong>public abstract Selector selector()</strong> 返回该key关联的Selector</li>
<li><strong>public final boolean isAcceptable()</strong> 检查OP_ACCEPT事件是否就绪。如果就绪，表示有新的stocket连接。</li>
<li><strong>public final boolean isConnectable()</strong> 检查OP_CONNECT事件是否就绪。如果就绪，表示可以发起连接到服务器。</li>
<li><strong>public final boolean isReadable()</strong> 检查OP_READ事件是否就绪，如果就绪则表示可以开始读取socket中的数据。</li>
<li><strong>public final boolean isWritable()</strong> 检查OP_WRITE事件是否就绪，如果就绪，表示可以写数据到Channel中。</li>
</ul>
<p>从上可以看到，SelectionKey其实是将channel实例和Selector关联起来，并且包含了就绪事件集合以及附加物的一个数据结构。</p>
<h3 id="将Channel注册到Selector"><a href="#将Channel注册到Selector" class="headerlink" title="将Channel注册到Selector"></a>将Channel注册到Selector</h3><p>实现了SelectableChannel的实例可以调用register方法进行注册。</p>
<pre><code class="java">SelectionKey selectionKey = socketChannel.register(selector, SelectionKey.OP_WRITE);
</code></pre>
<p>从register调试，就到了AbstractSelectableChannel的register方法：</p>
<pre><code class="java">public final SelectionKey register(Selector sel, int ops,
                                       Object att)
        throws ClosedChannelException
    &#123;
        synchronized (regLock) &#123;
            if (!isOpen())
                throw new ClosedChannelException();
            if ((ops &amp; ~validOps()) != 0)
                throw new IllegalArgumentException();
            // 如果是阻塞型Channel，则抛异常终止。
            // 所以需要调用configureBlocking(false)，标记为非阻塞Channel
            if (blocking)
                throw new IllegalBlockingModeException();
            // 从缓存中加锁获取与该Selector对应的SelectionKey
            SelectionKey k = findKey(sel);
            if (k != null) &#123;
                // 将入参指定的事件ops记录到interestOps中去。
                k.interestOps(ops);
                // 更新附加物，这里默认为null
                k.attach(att);
            &#125;
            // 如果SelectionKey不存在，则调用Selector的register方法来注册。
            if (k == null) &#123;
                // New registration
                synchronized (keyLock) &#123;
                    if (!isOpen())
                        throw new ClosedChannelException();
                    k = ((AbstractSelector)sel).register(this, ops, att);
                    addKey(k);
                &#125;
            &#125;
            return k;
        &#125;
    &#125;
</code></pre>
<p>注册步骤总结：</p>
<ul>
<li><ol>
<li>实现了SelectableChannel的实例调用register方法，入参需要指定Selector和注册事件，也可以指定附加物；</li>
</ol>
</li>
<li><ol start="2">
<li>在SelectableChannel的register方法中，先加锁去缓存中找有没有Selector对应的SelectionKey</li>
</ol>
<ul>
<li>2.1 如果有，就直接通过缓存的key来更新注册时间以及附加物。（因为这两个字段都是volatile，能确保可见性)。</li>
<li>2.2 如果没有，则通过Selector的register方法来注册事件，并返回新建的key。</li>
</ul>
</li>
</ul>
<h3 id="Selector使用样例"><a href="#Selector使用样例" class="headerlink" title="Selector使用样例"></a>Selector使用样例</h3><h4 id="Sever端"><a href="#Sever端" class="headerlink" title="Sever端"></a>Sever端</h4><pre><code class="java">
public class NioEchoServer &#123;
    private ByteBuffer writeBuffer = ByteBuffer.allocate(1024);
    private ByteBuffer readBuffer = ByteBuffer.allocate(1024);

    private static final int BUF_SIZE = 256;
    private static final int TIMEOUT = 10000;

    public void start() throws Exception &#123;
        // 打开服务端 Socket
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        
        // 打开 Selector
        Selector selector = Selector.open();

        // 服务端 Socket 监听8080端口, 并配置为非阻塞模式
        serverSocketChannel.socket().bind(new InetSocketAddress(8080));
        serverSocketChannel.configureBlocking(false);

        // 将 channel 注册到 selector 中.
        // 通常我们都是先注册一个 OP_ACCEPT 事件, 然后在 OP_ACCEPT 到来时, 再将这个 Channel 的 OP_READ
        // 注册到 Selector 中.
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        Scanner scanner = new Scanner(System.in);


        while (true) &#123;
            // 通过调用 select 方法, 阻塞地等待 channel I/O 可操作
            if (selector.select(TIMEOUT) == 0) &#123;
                System.out.println(&quot;.&quot;);
                continue;
            &#125;

            // 获取 I/O 操作就绪的 SelectionKey, 通过 SelectionKey 可以知道哪些 Channel 的哪类 I/O 操作已经就绪.
            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();

            while (keyIterator.hasNext()) &#123;

                SelectionKey key = keyIterator.next();

                // 当获取一个 SelectionKey 后, 就要将它删除, 表示我们已经对这个 IO 事件进行了处理.
                keyIterator.remove();

                if (key.isAcceptable()) &#123;
                    System.out.println(&quot;new client connected...&quot;);
                    // 当 OP_ACCEPT 事件到来时, 我们就有从 ServerSocketChannel 中获取一个 SocketChannel,
                    // 代表客户端的连接
                    // 注意, 在 OP_ACCEPT 事件中, 从 key.channel() 返回的 Channel 是 ServerSocketChannel.
                    // 而在 OP_WRITE 和 OP_READ 中, 从 key.channel() 返回的是 SocketChannel.
                    SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
                    clientChannel.configureBlocking(false);
                    //在 OP_ACCEPT 到来时, 再将这个 Channel 的 OP_READ 注册到 Selector 中.
                    // 注意, 这里我们如果没有设置 OP_READ 的话, 即 interest set 仍然是 OP_CONNECT 的话, 那么 select 方法会一直直接返回.
                    clientChannel.register(key.selector(), OP_READ, ByteBuffer.allocate(BUF_SIZE));
                &#125;

                if (key.isReadable()) &#123;
                    SocketChannel clientChannel = (SocketChannel) key.channel();
                    readBuffer = (ByteBuffer) key.attachment();
                    int bytesRead = clientChannel.read(readBuffer);
                    if (bytesRead == -1) &#123;
                        clientChannel.close();
                    &#125; else if (bytesRead &gt; 0) &#123;
                        key.interestOps(OP_READ | SelectionKey.OP_WRITE);
                        System.out.println(&quot;receive:&quot; + new String(readBuffer.array(), 0, bytesRead));
                    &#125;
                &#125;

                if (key.isValid() &amp;&amp; key.isWritable()) &#123;
                    System.out.print(&quot;send:&quot;);
                    String input = scanner.nextLine();

                    writeBuffer.clear();
                    writeBuffer.put(input.getBytes());
                    //将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位
                    writeBuffer.flip();
                    SocketChannel clientChannel = (SocketChannel) key.channel();
                    clientChannel.write(writeBuffer);

                    if (!writeBuffer.hasRemaining()) &#123;
                        key.interestOps(OP_READ);
                    &#125;
                    writeBuffer.compact();
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String args[]) throws Exception &#123;
        new NioEchoServer().start();
    &#125;
&#125;
</code></pre>
<h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><pre><code class="java">public class NioEchoClient &#123;

    private static ByteBuffer writeBuffer = ByteBuffer.allocate(1024);
    private static ByteBuffer readBuffer = ByteBuffer.allocate(1024);

    private static final int TIMEOUT = 10000;

    public static void main(String[] args) throws IOException &#123;
        // 打开socket通道
        SocketChannel sc = SocketChannel.open();
        // 设置为非阻塞
        sc.configureBlocking(false);
        // 连接服务器
        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
        // 打开选择器
        Selector selector = Selector.open();
        // 注册连接服务器
        sc.register(selector, SelectionKey.OP_CONNECT);

        Scanner scanner = new Scanner(System.in);

        while (true) &#123;
            while (selector.select(TIMEOUT) == 0) &#123;
                System.out.println(&quot;.&quot;);
                continue;
            &#125;

            //返回此选择器的已选择键集。
            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
            while (keyIterator.hasNext()) &#123;
                SelectionKey key = keyIterator.next();
                keyIterator.remove();
                // 判断此通道上是否正在进行连接操作。
                if (key.isConnectable()) &#123;
                    sc.finishConnect();
                    sc.register(selector, SelectionKey.OP_WRITE);
                    System.out.println(&quot;server connected...&quot;);
                    break;
                &#125; else if (key.isWritable()) &#123;
                    System.out.print(&quot;send:&quot;);
                    String message = scanner.nextLine();

                    writeBuffer.clear();
                    writeBuffer.put(message.getBytes());
                    //将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位
                    writeBuffer.flip();
                    sc.write(writeBuffer);

                    //注册写操作,每个chanel只能注册一个操作，最后注册的一个生效
                    //如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来
                    //int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
                    //使用interest集合
                    sc.register(selector, SelectionKey.OP_READ);
                    sc.register(selector, SelectionKey.OP_WRITE);
                    sc.register(selector, SelectionKey.OP_READ);

                &#125; else if (key.isReadable()) &#123;
                    SocketChannel client = (SocketChannel) key.channel();
                    //将缓冲区清空以备下次读取
                    readBuffer.clear();
                    int num = client.read(readBuffer);
                    System.out.println(&quot;receive:&quot; + new String(readBuffer.array(), 0, num));
                    //注册读操作，下一次读取
                    sc.register(selector, SelectionKey.OP_WRITE);
                &#125;
            &#125;
        &#125;

    &#125;
&#125;
</code></pre>
<ul>
<li><strong>参考资料</strong></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-nio/index.html"><strong>Java NIO Tutorial</strong></a> 很好的NIO教程，比国内的大部分资料都齐全。</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/10225159.html"><strong>10分钟看懂， Java NIO 底层原理</strong></a> 将Java四大IO模型讲得通俗易懂透彻的文章。</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 duval1024@gmail.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '0249fec24dcaf3532c31',
            clientSecret: '8ca1dd59f6b90d119d2206a05550f959dcc8e211',
            repo: 'baygeekarea_commet_area',
            owner: 'duval1024',
            admin: ['duval1024'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2024 Duval
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.png" class="alipay" title="扫码支持">
            <img src="/img/wechat.png" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #050505;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #050505;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #fbf4aB;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
