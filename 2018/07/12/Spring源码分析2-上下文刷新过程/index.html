<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spring源码分析2-上下文刷新过程分析 | 湾区极客</title>
  <meta name="keywords" content=" 源码分析 , Spring ">
  <meta name="description" content="Spring源码分析2-上下文刷新过程分析 | 湾区极客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="湾区极客——大湾区技术极客聚集地">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="https://bayareageek.cn/about/index.html">
<meta property="og:site_name" content="湾区极客">
<meta property="og:description" content="湾区极客——大湾区技术极客聚集地">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-02T10:14:39.000Z">
<meta property="article:modified_time" content="2024-03-02T10:15:55.401Z">
<meta property="article:author" content="湾仔">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>湾仔</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/duval1024"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/duvalyang"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:869296790@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=869296790&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(33)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="读书笔记">
            
            读书笔记
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="总结">
            
            总结
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Java">
            
            Java
            <small>(16)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JAVA">
            
            JAVA
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Spring">
            
            Spring
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="33">
<input type="hidden" id="yelog_site_word_count" value="90.3k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://bayareageek.cn/">湾区极客</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>代码整洁之道</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>读书笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>垃圾回收器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>垃圾收集器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>类加载机制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>生产问题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>输入输出流</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>文件描述符</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>线程池</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>性能分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>源码分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CAS原理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JVM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Netty</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NIO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Reactor</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 Java "
           href="/2021/04/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-6-ZGC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (六) ZGC 垃圾收集器">Java 虚拟机原理 (六) ZGC 垃圾收集器</span>
            <span class="post-date" title="2021-04-08 14:39:45">2021/04/08</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2021/02/09/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-3-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%B7%E6%81%A9%E6%B3%95%E5%88%99/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(3) 应用开发过程中的海恩法则">生产问题(3) 应用开发过程中的海恩法则</span>
            <span class="post-date" title="2021-02-09 22:18:16">2021/02/09</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/02/07/%E6%B7%B1%E5%85%A5-MySQL-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入 MySQL (六) 常见问题汇总">深入 MySQL (六) 常见问题汇总</span>
            <span class="post-date" title="2021-02-07 14:21:01">2021/02/07</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/06/%E6%B7%B1%E5%85%A5-MySQL-5-%E9%94%81/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (五) 锁">深入 MySQL (五) 锁</span>
            <span class="post-date" title="2021-02-06 22:19:08">2021/02/06</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/05/%E6%B7%B1%E5%85%A5-MySQL-4-%E7%B4%A2%E5%BC%95/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (四) 索引">深入 MySQL (四) 索引</span>
            <span class="post-date" title="2021-02-05 22:17:16">2021/02/05</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/02/04/%E6%B7%B1%E5%85%A5-MySQL-3-%E4%BA%8B%E5%8A%A1/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (三) 事务">深入 MySQL (三) 事务</span>
            <span class="post-date" title="2021-02-04 22:20:54">2021/02/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/01/30/%E6%B7%B1%E5%85%A5-MySQL-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (二) 文件系统">深入 MySQL (二) 文件系统</span>
            <span class="post-date" title="2021-01-30 12:00:39">2021/01/30</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2021/01/29/%E6%B7%B1%E5%85%A5-MySQL-1-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"
           data-tag="MySQL,数据库"
           data-author="" >
            <span class="post-title" title="深入 MySQL (一) 体系结构">深入 MySQL (一) 体系结构</span>
            <span class="post-date" title="2021-01-29 22:50:38">2021/01/29</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/11/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-5-G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (五) G1垃圾收集器深入">Java 虚拟机原理 (五) G1垃圾收集器深入</span>
            <span class="post-date" title="2021-01-11 01:00:07">2021/01/11</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/10/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-4-G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%A5%E9%97%A8/"
           data-tag="JVM,垃圾回收器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (四) G1垃圾收集器入门">Java 虚拟机原理 (四) G1垃圾收集器入门</span>
            <span class="post-date" title="2021-01-10 21:40:07">2021/01/10</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/09/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"
           data-tag="JVM,Java,垃圾收集器"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (三) 垃圾收集">Java 虚拟机原理 (三) 垃圾收集</span>
            <span class="post-date" title="2021-01-09 22:50:07">2021/01/09</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-2-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E5%9B%9E%E6%94%B6/"
           data-tag="JVM,Java"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (二) 对象创建与回收">Java 虚拟机原理 (二) 对象创建与回收</span>
            <span class="post-date" title="2021-01-08 23:56:07">2021/01/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2021/01/07/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-1-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"
           data-tag="JVM,Java"
           data-author="" >
            <span class="post-title" title="Java 虚拟机原理 (一) 内存划分">Java 虚拟机原理 (一) 内存划分</span>
            <span class="post-date" title="2021-01-07 22:56:07">2021/01/07</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/28/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1-Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"
           data-tag="Java,类加载机制"
           data-author="" >
            <span class="post-title" title="一文彻底掌握 Java 类加载机制">一文彻底掌握 Java 类加载机制</span>
            <span class="post-date" title="2020-12-28 22:11:49">2020/12/28</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/23/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1Java-IO%E7%B1%BB%E5%BA%93/"
           data-tag="Java,IO"
           data-author="" >
            <span class="post-title" title="一文彻底掌握Java IO类库">一文彻底掌握Java IO类库</span>
            <span class="post-date" title="2020-12-23 22:57:44">2020/12/23</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/12/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"
           data-tag="Java,文件描述符,输入输出流"
           data-author="" >
            <span class="post-title" title="深入理解Java文件输入输出流和文件描述符">深入理解Java文件输入输出流和文件描述符</span>
            <span class="post-date" title="2020-12-16 22:03:33">2020/12/16</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2020/12/15/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-2-ExceptionInInitializerError%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E8%A2%AB%E5%90%9E/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(2) ExceptionInInitializerError导致线程池中的线程异常被吞">生产问题(2) ExceptionInInitializerError导致线程池中的线程异常被吞</span>
            <span class="post-date" title="2020-12-15 17:26:29">2020/12/15</span>
        </a>
        
        
        <a  class="全部文章 读书笔记 "
           href="/2020/11/14/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"
           data-tag="读书笔记,代码整洁之道"
           data-author="" >
            <span class="post-title" title="《代码整洁之道》">《代码整洁之道》</span>
            <span class="post-date" title="2020-11-14 17:01:02">2020/11/14</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/10/26/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%89-%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之三 常用扩展点">再读Spring源码之三 常用扩展点</span>
            <span class="post-date" title="2020-10-26 18:31:25">2020/10/26</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/10/07/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BA%8C-FactoryBean/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之二 FactoryBean">再读Spring源码之二 FactoryBean</span>
            <span class="post-date" title="2020-10-07 21:00:39">2020/10/07</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2020/08/21/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%80-Spring%E5%A6%82%E4%BD%95%E5%AF%B9%E4%BB%98%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="再读Spring源码之一 Spring如何对付循环引用">再读Spring源码之一 Spring如何对付循环引用</span>
            <span class="post-date" title="2020-08-21 20:59:52">2020/08/21</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/15/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%85%AD-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8-Handler/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 六 流水线处理器: Handler">Netty 源码分析之 六 流水线处理器: Handler</span>
            <span class="post-date" title="2020-07-15 22:15:35">2020/07/15</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/09/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E4%BA%94-%E5%A5%94%E8%85%BE%E7%9A%84%E8%A1%80%E6%B6%B2-ByteBuf/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 五 奔腾的血液: ByteBuf">Netty 源码分析之 五 奔腾的血液: ByteBuf</span>
            <span class="post-date" title="2020-07-09 23:30:20">2020/07/09</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/07/04/Netty-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-%E5%9B%9B-Promise-%E4%B8%8E-Future-%E5%8F%8C%E5%AD%90%E6%98%9F%E7%9A%84%E7%A7%98%E5%AF%86/"
           data-tag="Netty,源码分析"
           data-author="" >
            <span class="post-title" title="Netty 源码分析之 四 Promise 与 Future: 双子星的秘密">Netty 源码分析之 四 Promise 与 Future: 双子星的秘密</span>
            <span class="post-date" title="2020-07-04 16:10:56">2020/07/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/06/12/Java%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Reactor%E6%A8%A1%E5%9E%8B/"
           data-tag="NIO,Reactor"
           data-author="" >
            <span class="post-title" title="Java高性能网络编程--Reactor模型">Java高性能网络编程--Reactor模型</span>
            <span class="post-date" title="2020-06-12 14:48:28">2020/06/12</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2020/05/14/%E8%AE%A4%E8%AF%86Java-NIO/"
           data-tag="NIO"
           data-author="" >
            <span class="post-title" title="认识 Java NIO">认识 Java NIO</span>
            <span class="post-date" title="2020-05-14 15:27:54">2020/05/14</span>
        </a>
        
        
        <a  class="全部文章 总结 "
           href="/2020/02/11/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-1-Java%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/"
           data-tag="生产问题"
           data-author="" >
            <span class="post-title" title="生产问题(1) Java进程CPU占用过高">生产问题(1) Java进程CPU占用过高</span>
            <span class="post-date" title="2020-02-11 21:49:14">2020/02/11</span>
        </a>
        
        
        <a  class="全部文章 JAVA "
           href="/2020/01/05/%E6%B7%B1%E5%85%A5JAVA%E8%AF%AD%E8%A8%80%E2%80%94CAS%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"
           data-tag="CAS原理"
           data-author="" >
            <span class="post-title" title="深入JAVA语言—CAS原理剖析">深入JAVA语言—CAS原理剖析</span>
            <span class="post-date" title="2020-01-05 18:16:26">2020/01/05</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/10/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903-%E5%AF%B9Bean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析3-对Bean循环依赖的处理">Spring源码分析3-对Bean循环依赖的处理</span>
            <span class="post-date" title="2018-10-12 15:47:01">2018/10/12</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-RESTful%20Web%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析1-RESTfulWeb启动过程">Spring源码分析1-RESTfulWeb启动过程</span>
            <span class="post-date" title="2018-07-12 11:47:01">2018/07/12</span>
        </a>
        
        
        <a  class="全部文章 Spring "
           href="/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%B7%E6%96%B0%E8%BF%87%E7%A8%8B/"
           data-tag="源码分析,Spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析2-上下文刷新过程分析">Spring源码分析2-上下文刷新过程分析</span>
            <span class="post-date" title="2018-07-12 11:47:01">2018/07/12</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2017/08/10/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"
           data-tag="线程池"
           data-author="" >
            <span class="post-title" title="Java 线程池详解">Java 线程池详解</span>
            <span class="post-date" title="2017-08-10 16:47:18">2017/08/10</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2017/06/18/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"
           data-tag="JVM,性能分析"
           data-author="" >
            <span class="post-title" title="JVM性能监控工具总结">JVM性能监控工具总结</span>
            <span class="post-date" title="2017-06-18 16:47:54">2017/06/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Spring源码分析2-上下文刷新过程" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Spring源码分析2-上下文刷新过程分析</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Spring">Spring</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">源码分析</a>
            
            <a class="color2">Spring</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-03-03 16:57:04'>2018-07-12 11:47</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:11.4k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#prepareRefresh"><span class="toc-text">prepareRefresh</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#obtainFreshBeanFactory"><span class="toc-text">obtainFreshBeanFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prepareBeanFactory"><span class="toc-text">prepareBeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#postProcessBeanFactory"><span class="toc-text">postProcessBeanFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invokeBeanFactoryPostProcessors"><span class="toc-text">invokeBeanFactoryPostProcessors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%951%EF%BC%9AinvokeBeanDefinitionRegistryPostProcessors"><span class="toc-text">重要方法1：invokeBeanDefinitionRegistryPostProcessors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%952%EF%BC%9AinvokeBeanFactoryPostProcessors"><span class="toc-text">重要方法2：invokeBeanFactoryPostProcessors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#registerBeanPostProcessors"><span class="toc-text">registerBeanPostProcessors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initMessageSource"><span class="toc-text">initMessageSource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initApplicationEventMulticaster"><span class="toc-text">initApplicationEventMulticaster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onRefresh"><span class="toc-text">onRefresh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#registerListeners"><span class="toc-text">registerListeners</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finishBeanFactoryInitialization"><span class="toc-text">finishBeanFactoryInitialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finishRefresh"><span class="toc-text">finishRefresh</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇《<a target="_blank" rel="noopener" href="https://duvalcc.github.io/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-RESTful%20Web%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">Spring源码分析1-RESTfulWeb启动过程</a>》已经对RESTfulWeb的启动过程进行了概览。其中跳过了比较复杂的上下文刷新过程，这篇文章将对上下文刷新过程进行详细分析。请看！</p>
<span id="more"></span>
<p><strong>说在前边：本文是我阅读RestfulWeb启动过程写的流水账，瑕疵多多。</strong></p>
<p>刷新上下文关键代码：</p>
<pre><code class="java">@Override
    public void refresh() throws BeansException, IllegalStateException &#123;
        synchronized (this.startupShutdownMonitor) &#123;
            // Prepare this context for refreshing. 刷新前准备工作
            prepareRefresh();

            // Tell the subclass to refresh the internal bean factory.  
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context.
            prepareBeanFactory(beanFactory);

            try &#123;
                // Allows post-processing of the bean factory in context subclasses.
                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                initMessageSource();

                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                onRefresh();

                // Check for listener beans and register them.
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            &#125;

            catch (BeansException ex) &#123;
                if (logger.isWarnEnabled()) &#123;
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                &#125;

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset &#39;active&#39; flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            &#125;

            finally &#123;
                // Reset common introspection caches in Spring&#39;s core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            &#125;
        &#125;
    &#125;
</code></pre>
<p>下边对这些调用的方法逐个分析</p>
<h2 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h2><p>这个方法是做刷新前的一些准备工作</p>
<pre><code class="java">/**
     * Prepare this context for refreshing, setting its startup date and
     * active flag as well as performing any initialization of property sources.
     */
    protected void prepareRefresh() &#123;
        this.startupDate = System.currentTimeMillis();
        this.closed.set(false);
        this.active.set(true);

        if (logger.isInfoEnabled()) &#123;
            logger.info(&quot;Refreshing &quot; + this);
        &#125;
        // Initialize any placeholder property sources in the context environment
        initPropertySources();

        // Validate that all properties marked as required are resolvable
        // see ConfigurablePropertyResolver#setRequiredProperties
        getEnvironment().validateRequiredProperties();

        // Allow for the collection of early ApplicationEvents,
        // to be published once the multicaster is available...
        this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();
    &#125;
</code></pre>
<p><strong>initPropertySources</strong>其实是为了替换两个servlet有关的属性,我暂时没搞懂这两个属性是干嘛的,mark之:</p>
<pre><code class="java">public static void initServletPropertySources(MutablePropertySources sources,
            @Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) &#123;
        Assert.notNull(sources, &quot;&#39;propertySources&#39; must not be null&quot;);
        String name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;
        if (servletContext != null &amp;&amp; sources.contains(name) &amp;&amp; sources.get(name) instanceof StubPropertySource) &#123;
            sources.replace(name, new ServletContextPropertySource(name, servletContext));
        &#125;
        name = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME;
        if (servletConfig != null &amp;&amp; sources.contains(name) &amp;&amp; sources.get(name) instanceof StubPropertySource) &#123;
            sources.replace(name, new ServletConfigPropertySource(name, servletConfig));
        &#125;
    &#125;
</code></pre>
<p><strong>validateRequiredProperties</strong>是为了校验一些必需的参数。<br><strong>earlyApplicationEvents</strong>在这里进行初始化为LinkedHashSet，用来存放早期的一些Applicationevents。<br>这里调试发现，对于<a target="_blank" rel="noopener" href="https://github.com/spring-guides/gs-rest-service.git">gs-rest-service</a>，其实initPropertySources 和 validateRequiredProperties 都没有做任何动作。</p>
<h2 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h2><pre><code class="java">/**
     * Tell the subclass to refresh the internal bean factory.
     * @return the fresh BeanFactory instance
     * @see #refreshBeanFactory()
     * @see #getBeanFactory()
     */
    protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;
        refreshBeanFactory();
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
        &#125;
        return beanFactory;
    &#125;
</code></pre>
<p>这里并没有做很多动作，首先是刷新一下BeanFactory，其实就是在实现子类GenericApplicationContext里设置一下新的序列化ID；然后getBeanFactory()其实拿的是子类GenericApplicationContext里的DefaultListableBeanFactory,这是在其默认构造函数里新建的实例。</p>
<h2 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h2><pre><code class="java">/**
     * Configure the factory&#39;s standard context characteristics,
     * such as the context&#39;s ClassLoader and post-processors.
     * @param beanFactory the BeanFactory to configure
     */
    protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;
        // Tell the internal bean factory to use the context&#39;s class loader etc.
        beanFactory.setBeanClassLoader(getClassLoader());
        //设置标准的Bean解释器，解释形如&quot;#&#123;&#125;&quot;
        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
        //添加PropertyEditor注册器
        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

        // Configure the bean factory with context callbacks.
        //添加一个BeanPostProcessor
        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
        //忽略这些接口的自动注入
        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

        // BeanFactory interface not registered as resolvable type in a plain factory.
        // MessageSource registered (and found for autowiring) as a bean.
        //使用注入值来注册几个特殊的依赖
        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
        beanFactory.registerResolvableDependency(ResourceLoader.class, this);
        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
        beanFactory.registerResolvableDependency(ApplicationContext.class, this);

        // Register early post-processor for detecting inner beans as ApplicationListeners.
        // 添加一个BeanPostProcessor
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

        // Detect a LoadTimeWeaver and prepare for weaving, if found.
        //添加一个BeanPostProcessor，这个LoadTimeWeaverAwareProcessor跟第三方织入有关，以后再深入了解
        if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            // Set a temporary ClassLoader for type matching.
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        &#125;

        // Register default environment beans.
        //注册几个单例
        if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;
            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
        &#125;
        if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;
            beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
        &#125;
        if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;
            beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
        &#125;
    &#125;

</code></pre>
<p>过程直接看上边注释就可以大致了解。这里再看看BeanPostProcessor接口是干嘛的:</p>
<pre><code class="java">/**
 * Factory hook that allows for custom modification of new bean instances,
 * e.g. checking for marker interfaces or wrapping them with proxies.
 *
 * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their
 * bean definitions and apply them to any beans subsequently created.
 * Plain bean factories allow for programmatic registration of post-processors,
 * applying to all beans created through this factory.
 *
 * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces
 * or the like will implement &#123;@link #postProcessBeforeInitialization&#125;,
 * while post-processors that wrap beans with proxies will normally
 * implement &#123;@link #postProcessAfterInitialization&#125;.
 *
 * @author Juergen Hoeller
 * @since 10.10.2003
 * @see InstantiationAwareBeanPostProcessor
 * @see DestructionAwareBeanPostProcessor
 * @see ConfigurableBeanFactory#addBeanPostProcessor
 * @see BeanFactoryPostProcessor
 */
public interface BeanPostProcessor &#123;

    /**
     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean
     * initialization callbacks (like InitializingBean&#39;s &#123;@code afterPropertiesSet&#125;
     * or a custom init-method). The bean will already be populated with property values.
     * The returned bean instance may be a wrapper around the original.
     * &lt;p&gt;The default implementation returns the given &#123;@code bean&#125; as-is.
     * @param bean the new bean instance
     * @param beanName the name of the bean
     * @return the bean instance to use, either the original or a wrapped one;
     * if &#123;@code null&#125;, no subsequent BeanPostProcessors will be invoked
     * @throws org.springframework.beans.BeansException in case of errors
     * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
     */
    @Nullable
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;
        return bean;
    &#125;

    /**
     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean
     * initialization callbacks (like InitializingBean&#39;s &#123;@code afterPropertiesSet&#125;
     * or a custom init-method). The bean will already be populated with property values.
     * The returned bean instance may be a wrapper around the original.
     * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean
     * instance and the objects created by the FactoryBean (as of Spring 2.0). The
     * post-processor can decide whether to apply to either the FactoryBean or created
     * objects or both through corresponding &#123;@code bean instanceof FactoryBean&#125; checks.
     * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a
     * &#123;@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,
     * in contrast to all other BeanPostProcessor callbacks.
     * &lt;p&gt;The default implementation returns the given &#123;@code bean&#125; as-is.
     * @param bean the new bean instance
     * @param beanName the name of the bean
     * @return the bean instance to use, either the original or a wrapped one;
     * if &#123;@code null&#125;, no subsequent BeanPostProcessors will be invoked
     * @throws org.springframework.beans.BeansException in case of errors
     * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
     * @see org.springframework.beans.factory.FactoryBean
     */
    @Nullable
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;
        return bean;
    &#125;

&#125;
</code></pre>
<p>注释非常长，其实可以看到接口需要实现两个方法postProcessBeforeInitialization和postProcessAfterInitialization，顾名思义，可以知道这个接口的作用是在bean初始化前后分别做一些操作。</p>
<p>所以上边的ApplicationContextAwareProcessor正是实现了BeanPostProcessor，具体的作用是想在postProcessBeforeInitialization里,对实现了EnvironmentAware, EmbeddedValueResolverAware, ResourceLoaderAware, ApplicationEventPublisherAware, MessageSourceAware, ApplicationContextAware 等Aware接口的Bean进行一些接口特定的初始化动作。</p>
<p><strong>另外还有添加另外一个BeanPostProcessor为 LoadTimeWeaverAwareProcessor，这个是跟织入有关的，因为对AOP还不熟悉，后续再深入研究，这里mark之。</strong></p>
<h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><pre><code class="java">beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));
beanFactory.ignoreDependencyInterface(ServletContextAware.class);
</code></pre>
<p>这里的postProcessBeanFactory#postProcessBeanFactory是个空方法，调用这个方法其实是调用了子类ServletWebServerApplicationContext和AnnotationConfigServletWebServerApplicationContext的里实现的方法。也只是看到注册了一个BeanPostProcessor,名叫WebApplicationContextServletContextAwareProcessor，没有做别的操作。</p>
<h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>这应该是最复杂的一个过程了，断断续续看了我一周多才看完。好吧， 请看：</p>
<pre><code class="java">/**
     * Instantiate and invoke all registered BeanFactoryPostProcessor beans,
     * respecting explicit order if given.
     * &lt;p&gt;Must be called before singleton instantiation.
     */
    protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;
        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

        // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
        // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
        if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        &#125;
    &#125;
</code></pre>
<p>入口非常简单，大部分逻辑都放在了工具类的方法invokeBeanFactoryPostProcessors。最后会检查是否有LoadTimeWeaver，如果有则做一些织入前的准备。我对Java的织入切面不够熟悉，大致分三类：编译期织入、类加载期织入和运行期织入。这个留到以后再去拓展一下。</p>
<p>下面对工具类的方法展开：</p>
<pre><code class="java">public static void invokeBeanFactoryPostProcessors(
            ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;

        // Invoke BeanDefinitionRegistryPostProcessors first, if any.
        Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();

        if (beanFactory instanceof BeanDefinitionRegistry) &#123;
            BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
            List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;&gt;();
            List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new LinkedList&lt;&gt;();

            for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;
                if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;
                    BeanDefinitionRegistryPostProcessor registryProcessor =
                            (BeanDefinitionRegistryPostProcessor) postProcessor;
                    registryProcessor.postProcessBeanDefinitionRegistry(registry);
                    registryProcessors.add(registryProcessor);
                &#125;
                else &#123;
                    regularPostProcessors.add(postProcessor);
                &#125;
            &#125;

            // Do not initialize FactoryBeans here: We need to leave all regular beans
            // uninitialized to let the bean factory post-processors apply to them!
            // Separate between BeanDefinitionRegistryPostProcessors that implement
            // PriorityOrdered, Ordered, and the rest.
            List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();

            // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
            String[] postProcessorNames =
                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) &#123;
                if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                &#125;
            &#125;
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();

            // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) &#123;
                if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                &#125;
            &#125;
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();

            // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
            boolean reiterate = true;
            while (reiterate) &#123;
                reiterate = false;
                postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                for (String ppName : postProcessorNames) &#123;
                    if (!processedBeans.contains(ppName)) &#123;
                        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                        processedBeans.add(ppName);
                        reiterate = true;
                    &#125;
                &#125;
                sortPostProcessors(currentRegistryProcessors, beanFactory);
                registryProcessors.addAll(currentRegistryProcessors);
                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                currentRegistryProcessors.clear();
            &#125;

            // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
            invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
            invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
        &#125;

        else &#123;
            // Invoke factory processors registered with the context instance.
            invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
        &#125;

        // Do not initialize FactoryBeans here: We need to leave all regular beans
        // uninitialized to let the bean factory post-processors apply to them!
        String[] postProcessorNames =
                beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

        // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
        for (String ppName : postProcessorNames) &#123;
            if (processedBeans.contains(ppName)) &#123;
                // skip - already processed in first phase above
            &#125;
            else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;
                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
            &#125;
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;
                orderedPostProcessorNames.add(ppName);
            &#125;
            else &#123;
                nonOrderedPostProcessorNames.add(ppName);
            &#125;
        &#125;

        // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
        invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

        // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
        List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
        for (String postProcessorName : orderedPostProcessorNames) &#123;
            orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
        &#125;
        sortPostProcessors(orderedPostProcessors, beanFactory);
        invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

        // Finally, invoke all other BeanFactoryPostProcessors.
        List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
        for (String postProcessorName : nonOrderedPostProcessorNames) &#123;
            nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
        &#125;
        invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

        // Clear cached merged bean definitions since the post-processors might have
        // modified the original metadata, e.g. replacing placeholders in values...
        beanFactory.clearMetadataCache();
    &#125;
</code></pre>
<p>非常长的方法，大致可以从第一个if那里划分两块逻辑。第一部分是处理BeanDefinitionRegistryPostProcessor的，第二部分是处理BeanFactoryPostProcessor。先看第一部分的流程：</p>
<ul>
<li>先看传入的beanFactory是不是BeanDefinitionRegistry类型，然后将传入的beanFactoryPostProcessors分为两类，一类实现了BeanDefinitionRegistryPostProcessor接口，存在registryProcessors；另一类没有实现该接口，存在regularPostProcessors。</li>
<li>接着，去beanFactory里捞出所有的实现了BeanDefinitionRegistryPostProcessor的Bean的名字，并从中捞出实现了PriorityOrdered接口的Bean，排序后，存到了上一步的registryProcessors中。然后触发<strong>invokeBeanDefinitionRegistryPostProcessors</strong>，这个方法主要是解析Configuratio类的，具体比较复杂，后文详细分析。</li>
<li>再接着，跟上边的类似，捞出所有的实现了BeanDefinitionRegistryPostProcessor以及Ordered接口的Bean，做类似的动作。由此可以看到PriorityOrdered接口优先级更高。这两个排序接口的应用还可以看看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/OrderComparator.java">OrderComparator</a>.</li>
<li>接下来还是跟上边类似，这次用了一个while循环，确保不会遗漏任何一个实现了BeanDefinitionRegistryPostProcessor接口的bean</li>
<li>最后对上边所有的调用<strong>invokeBeanFactoryPostProcessors</strong>，这也是一个复杂的方法，后文详细分析。</li>
</ul>
<p>第一部分总结：主要是周而复始地处理实现了BeanDefinitionRegistryPostProcessor接口的bean，一共重复了三次。另外，比较重要的方法有两个<strong>invokeBeanDefinitionRegistryPostProcessors</strong> 和 <strong>invokeBeanFactoryPostProcessors</strong></p>
<p>再来看看第二部分：</p>
<ul>
<li>跟第一部分类似，捞出所有实现了BeanFactoryPostProcessor接口的bean的名字，然后根据是否实现了PriorityOrdered 和 Ordered ，分成三类，分别存到三个不同的list里去。</li>
<li>分别对priorityOrderedPostProcessors和orderedPostProcessors，进行排序，并且调用<strong>invokeBeanFactoryPostProcessors</strong></li>
<li>再对nonOrderedPostProcessors调用<strong>invokeBeanFactoryPostProcessors</strong></li>
</ul>
<p>第二部分总结：跟第一部分类似，有一个相同的重要方法：<strong>invokeBeanFactoryPostProcessors</strong></p>
<p>现在开始重点分析这两个重要方法：</p>
<h4 id="重要方法1：invokeBeanDefinitionRegistryPostProcessors"><a href="#重要方法1：invokeBeanDefinitionRegistryPostProcessors" class="headerlink" title="重要方法1：invokeBeanDefinitionRegistryPostProcessors"></a>重要方法1：invokeBeanDefinitionRegistryPostProcessors</h4><pre><code class="java">/**
     * Invoke the given BeanDefinitionRegistryPostProcessor beans.
     */
    private static void invokeBeanDefinitionRegistryPostProcessors(
            Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) &#123;

        for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;
            postProcessor.postProcessBeanDefinitionRegistry(registry);
        &#125;
    &#125;
</code></pre>
<p>调试发现，这个方法进去，只有一个postProcessor，类型为ConfigurationClassPostProcessor,看看注释说到：<br>ConfigurationClassPostProcessor是一个用于引导加载@Configuration标注的类的BeanFactoryPostProcessor接口的实例。xml加载方式一般用<a href="context:annotation-config/">context:annotation-config/</a> 或者 <a href="context:component-scan/">context:component-scan/</a>注册，spring boot的的非xml注册方式的话在ApplicationContext对象创建时，会调用 AnnotationConfigUtils.registerAnnotationConfigProcessors() 注册这个BeanFactoryPostProcessor。然后说到这个ConfigurationClassPostProcessor拥有最高优先级，因为其他的通过方法注入的bean都要等这个ConfigurationClassPostProcessor执行完后才能注册。</p>
<p>这里有点奇怪的是ConfigurationClassPostProcessor的Orderd接口的是实现方法返回的是最低优先级，这里应该跟上文的最高优先级没啥联系，应该是BeanDefinitionRegistryPostProcessor之间的优先级，但为啥这玩意儿的优先级要最低呢？不懂…以后会懂的…</p>
<pre><code class="java">@Override
    public int getOrder() &#123;
        return Ordered.LOWEST_PRECEDENCE;  // within PriorityOrdered
    &#125;
</code></pre>
<p>接着看ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法：</p>
<pre><code class="java">/**
     * Derive further bean definitions from the configuration classes in the registry.
     */
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;
        int registryId = System.identityHashCode(registry);
        if (this.registriesPostProcessed.contains(registryId)) &#123;
            throw new IllegalStateException(
                    &quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);
        &#125;
        if (this.factoriesPostProcessed.contains(registryId)) &#123;
            throw new IllegalStateException(
                    &quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);
        &#125;
        this.registriesPostProcessed.add(registryId);

        processConfigBeanDefinitions(registry);
    &#125;
</code></pre>
<p>先是获取这个registry的identityHashCode，这个code其实是对象object的内存地址，一旦对象实例化后就不会再变动，但对象的hashcode一般是重载过的，一般是伴随对象的字段值变化而变化。</p>
<p>这里先拿到registryId，然后看看这个registry有没有被处理过。</p>
<p>然后就进入了processConfigBeanDefinitions(registry)方法：</p>
<pre><code class="java">/**
     * Build and validate a configuration model based on the registry of
     * &#123;@link Configuration&#125; classes.
     */
    public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;
        List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
        String[] candidateNames = registry.getBeanDefinitionNames();

        for (String beanName : candidateNames) &#123;
            BeanDefinition beanDef = registry.getBeanDefinition(beanName);
            if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
                    ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
                &#125;
            &#125;
            else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;
                configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
            &#125;
        &#125;

        // Return immediately if no @Configuration classes were found
        if (configCandidates.isEmpty()) &#123;
            return;
        &#125;

        // Sort by previously determined @Order value, if applicable
        configCandidates.sort((bd1, bd2) -&gt; &#123;
            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
            return Integer.compare(i1, i2);
        &#125;);

        // Detect any custom bean name generation strategy supplied through the enclosing application context
        SingletonBeanRegistry sbr = null;
        if (registry instanceof SingletonBeanRegistry) &#123;
            sbr = (SingletonBeanRegistry) registry;
            if (!this.localBeanNameGeneratorSet) &#123;
                BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
                if (generator != null) &#123;
                    this.componentScanBeanNameGenerator = generator;
                    this.importBeanNameGenerator = generator;
                &#125;
            &#125;
        &#125;

        if (this.environment == null) &#123;
            this.environment = new StandardEnvironment();
        &#125;

        // Parse each @Configuration class
        ConfigurationClassParser parser = new ConfigurationClassParser(
                this.metadataReaderFactory, this.problemReporter, this.environment,
                this.resourceLoader, this.componentScanBeanNameGenerator, registry);

        Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
        Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
        do &#123;
            parser.parse(candidates);
            parser.validate();

            Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
            configClasses.removeAll(alreadyParsed);

            // Read the model and create bean definitions based on its content
            if (this.reader == null) &#123;
                this.reader = new ConfigurationClassBeanDefinitionReader(
                        registry, this.sourceExtractor, this.resourceLoader, this.environment,
                        this.importBeanNameGenerator, parser.getImportRegistry());
            &#125;
            this.reader.loadBeanDefinitions(configClasses);
            alreadyParsed.addAll(configClasses);

            candidates.clear();
            if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;
                String[] newCandidateNames = registry.getBeanDefinitionNames();
                Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
                Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
                for (ConfigurationClass configurationClass : alreadyParsed) &#123;
                    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
                &#125;
                for (String candidateName : newCandidateNames) &#123;
                    if (!oldCandidateNames.contains(candidateName)) &#123;
                        BeanDefinition bd = registry.getBeanDefinition(candidateName);
                        if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                                !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;
                            candidates.add(new BeanDefinitionHolder(bd, candidateName));
                        &#125;
                    &#125;
                &#125;
                candidateNames = newCandidateNames;
            &#125;
        &#125;
        while (!candidates.isEmpty());

        // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
        if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;
            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
        &#125;

        if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123;
            // Clear cache in externally provided MetadataReaderFactory; this is a no-op
            // for a shared cache since it&#39;ll be cleared by the ApplicationContext.
            ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
        &#125;
    &#125;
</code></pre>
<p>方法很长，逐步分析：</p>
<ul>
<li>第一，先是去registry里取出全部注册的的名字，然后看看这些bean，如果已经标记了是FullConfiguration或者LiteConfiguration的话，表示已经处理过了，跳过；否则的话，通过工具类方法ConfigurationClassUtils.checkConfigurationClassCandidate去检查是不是@Configuration和@Component标记的bean，是的话，加入候选configCandidates中；</li>
</ul>
<blockquote>
<p>这里先对工具类ConfigurationClassUtils出现的三个方法进行展开看看：<br><strong>isFullConfigurationCandidate</strong> 判断bean是否被@Configuration注解标记<br><strong>isLiteConfigurationCandidate</strong> 判断bean是否被@Component、@ComponentScan、@Import、@ImportResource 注解标记，或者包含一个被@Bean注解标记的方法。<br><strong>checkConfigurationClassCandidate</strong> 检查bean是不是Full或者Lite的Configuration候选类。这个方法主要是获取该类的AnnotationMetadata，然后根据包含的注解情况，给标注为Full或者是Lite</p>
</blockquote>
<ul>
<li>第二，如果configCandidates为空，直接返回结束方法；否则，对其排序，取@Order指定的值进行比较（默认Ordered#LOWEST_PRECEDENCE）；</li>
<li>第三，看看是否有注册单例的BeanNameGenerator，这个玩意儿是用于生成bean名字的。举个例子，比如@Reposity注解的类会被spring自动识别为bean，这个bean默认的名字是类名首字母小写，如果有注册BeanNameGenerator的话，就可以自定义这个bean的名字；</li>
<li>第四，这一块实例化一个ConfigurationClassParser，顾名思义，就是用来解析@Configuration的类的解析器。这里一个do…while…循环，直到所有的类都被解析完毕。</li>
</ul>
<p>现在重点分析ConfigurationClassParser，先看parse方法：</p>
<pre><code class="java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123;
        this.deferredImportSelectors = new LinkedList&lt;&gt;();

        for (BeanDefinitionHolder holder : configCandidates) &#123;
            BeanDefinition bd = holder.getBeanDefinition();
            try &#123;
                if (bd instanceof AnnotatedBeanDefinition) &#123;
                    parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
                &#125;
                else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;
                    parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
                &#125;
                else &#123;
                    parse(bd.getBeanClassName(), holder.getBeanName());
                &#125;
            &#125;
            catch (BeanDefinitionStoreException ex) &#123;
                throw ex;
            &#125;
            catch (Throwable ex) &#123;
                throw new BeanDefinitionStoreException(
                        &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
            &#125;
        &#125;

        processDeferredImportSelectors();
    &#125;
</code></pre>
<p>parse方法一进来就可以看到，根据BeanDefinition的类型，分别调用三个不同的parse方法。然后看三个parse方法殊途同归，最后都是调用了processConfigurationClass方法，看下这个方法代码：</p>
<pre><code class="java">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException &#123;
        if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;
            return;
        &#125;

        ConfigurationClass existingClass = this.configurationClasses.get(configClass);
        if (existingClass != null) &#123;
            if (configClass.isImported()) &#123;
                if (existingClass.isImported()) &#123;
                    existingClass.mergeImportedBy(configClass);
                &#125;
                // Otherwise ignore new imported config class; existing non-imported class overrides it.
                return;
            &#125;
            else &#123;
                // Explicit bean definition found, probably replacing an import.
                // Let&#39;s remove the old one and go with the new one.
                this.configurationClasses.remove(configClass);
                this.knownSuperclasses.values().removeIf(configClass::equals);
            &#125;
        &#125;

        // Recursively process the configuration class and its superclass hierarchy.
        SourceClass sourceClass = asSourceClass(configClass);
        do &#123;
            sourceClass = doProcessConfigurationClass(configClass, sourceClass);
        &#125;
        while (sourceClass != null);

        this.configurationClasses.put(configClass, configClass);
    &#125;
</code></pre>
<p>processConfigurationClass一开始先是检查configuration的Condition条件是否满足，不满足的话直接返回。shouldSkip方法展开看看，有点小意思：</p>
<pre><code class="java">/**
     * Determine if an item should be skipped based on &#123;@code @Conditional&#125; annotations.
     * @param metadata the meta data
     * @param phase the phase of the call
     * @return if the item should be skipped
     */
    public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) &#123;
        if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) &#123;
            return false;
        &#125;

        if (phase == null) &#123;
            if (metadata instanceof AnnotationMetadata &amp;&amp;
                    ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;
                return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);
            &#125;
            return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);
        &#125;

        List&lt;Condition&gt; conditions = new ArrayList&lt;&gt;();
        for (String[] conditionClasses : getConditionClasses(metadata)) &#123;
            for (String conditionClass : conditionClasses) &#123;
                Condition condition = getCondition(conditionClass, this.context.getClassLoader());
                conditions.add(condition);
            &#125;
        &#125;

        AnnotationAwareOrderComparator.sort(conditions);

        for (Condition condition : conditions) &#123;
            ConfigurationPhase requiredPhase = null;
            if (condition instanceof ConfigurationCondition) &#123;
                requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();
            &#125;
            if ((requiredPhase == null || requiredPhase == phase) &amp;&amp; !condition.matches(this.context, metadata)) &#123;
                return true;
            &#125;
        &#125;

        return false;
    &#125;
</code></pre>
<p>在shouldSkip里看到从getConditionClasses(metadata)里获取所有的Conditional条件，然后一个for循环遍历所有的<br>condition看是否match，一旦没有match就意味着要skip了。这里可以看到@Conditional、ConditionalOnBean等Condition类的注解是与关系的。Condition类的注解使用不在本文讨论范围，以后会展开看看。mark</p>
<p>继续看processConfigurationClass方法，判断完是否skip之后，再看看是否已经解析过这个Configuration，一旦解析过，如果两者都是import进来的，则合并两者的ImportedBy；如果先解析的是import进来的的，则抛弃之，重新解析。</p>
<p>然后将configClass转化为SourceClass类型，SourceClass类型里有很多强大的方法，比如获得内部类getMemberClasses()。</p>
<p>然后循环进行doProcessConfigurationClass(configClass, sourceClass) 去看看：</p>
<pre><code class="java">/**
     * Apply processing and build a complete &#123;@link ConfigurationClass&#125; by reading the
     * annotations, members and methods from the source class. This method can be called
     * multiple times as relevant sources are discovered.
     * @param configClass the configuration class being build
     * @param sourceClass a source class
     * @return the superclass, or &#123;@code null&#125; if none found or previously processed
     */
    @Nullable
    protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
            throws IOException &#123;

        // Recursively process any member (nested) classes first
        processMemberClasses(configClass, sourceClass);

        // Process any @PropertySource annotations
        for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
                sourceClass.getMetadata(), PropertySources.class,
                org.springframework.context.annotation.PropertySource.class)) &#123;
            if (this.environment instanceof ConfigurableEnvironment) &#123;
                processPropertySource(propertySource);
            &#125;
            else &#123;
                logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
                        &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
            &#125;
        &#125;

        // Process any @ComponentScan annotations
        Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
                sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
        if (!componentScans.isEmpty() &amp;&amp;
                !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;
            for (AnnotationAttributes componentScan : componentScans) &#123;
                // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
                Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
                        this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
                // Check the set of scanned definitions for any further config classes and parse recursively if needed
                for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;
                    BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                    if (bdCand == null) &#123;
                        bdCand = holder.getBeanDefinition();
                    &#125;
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;
                        parse(bdCand.getBeanClassName(), holder.getBeanName());
                    &#125;
                &#125;
            &#125;
        &#125;

        // Process any @Import annotations
        processImports(configClass, sourceClass, getImports(sourceClass), true);

        // Process any @ImportResource annotations
        AnnotationAttributes importResource =
                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
        if (importResource != null) &#123;
            String[] resources = importResource.getStringArray(&quot;locations&quot;);
            Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
            for (String resource : resources) &#123;
                String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
                configClass.addImportedResource(resolvedResource, readerClass);
            &#125;
        &#125;

        // Process individual @Bean methods
        Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
        for (MethodMetadata methodMetadata : beanMethods) &#123;
            configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
        &#125;

        // Process default methods on interfaces
        processInterfaces(configClass, sourceClass);

        // Process superclass, if any
        if (sourceClass.getMetadata().hasSuperClass()) &#123;
            String superclass = sourceClass.getMetadata().getSuperClassName();
            if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
                    !this.knownSuperclasses.containsKey(superclass)) &#123;
                this.knownSuperclasses.put(superclass, configClass);
                // Superclass found, return its annotation metadata and recurse
                return sourceClass.getSuperClass();
            &#125;
        &#125;

        // No superclass -&gt; processing is complete
        return null;
    &#125;
</code></pre>
<p>很长的方法，但是清晰，从上而下分别是解析嵌套类（member class)、@PropertySource、@ComponentScan、@Import、@ImportResource、@Bean、接口方法、超类等；</p>
<p>分别看看：</p>
<ul>
<li><strong>解析嵌套类（member class)</strong> 调用<strong>processMemberClasses</strong>方法，先从sourceClass里取出所有的memberClass，判断如果是Configuration类的话，加入候选集。然后通过importStack栈来避免死循环，接下来又调用processConfigurationClass方法递归下去解析</li>
</ul>
<pre><code class="java">/**
     * Register member (nested) classes that happen to be configuration classes themselves.
     */
    private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException &#123;
        Collection&lt;SourceClass&gt; memberClasses = sourceClass.getMemberClasses();
        if (!memberClasses.isEmpty()) &#123;
            List&lt;SourceClass&gt; candidates = new ArrayList&lt;&gt;(memberClasses.size());
            for (SourceClass memberClass : memberClasses) &#123;
                if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &amp;&amp;
                        !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) &#123;
                    candidates.add(memberClass);
                &#125;
            &#125;
            OrderComparator.sort(candidates);
            for (SourceClass candidate : candidates) &#123;
                if (this.importStack.contains(configClass)) &#123;
                    this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
                &#125;
                else &#123;
                    this.importStack.push(configClass);
                    try &#123;
                        processConfigurationClass(candidate.asConfigClass(configClass));
                    &#125;
                    finally &#123;
                        this.importStack.pop();
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;

</code></pre>
<ul>
<li><strong>@PropertySource</strong> 获取所有的@PropertySource，然后逐个解析呗，没啥复杂的，请直接看代码：</li>
</ul>
<pre><code class="java">/**
     * Process the given &lt;code&gt;@PropertySource&lt;/code&gt; annotation metadata.
     * @param propertySource metadata for the &lt;code&gt;@PropertySource&lt;/code&gt; annotation found
     * @throws IOException if loading a property source failed
     */
    private void processPropertySource(AnnotationAttributes propertySource) throws IOException &#123;
        String name = propertySource.getString(&quot;name&quot;);
        if (!StringUtils.hasLength(name)) &#123;
            name = null;
        &#125;
        String encoding = propertySource.getString(&quot;encoding&quot;);
        if (!StringUtils.hasLength(encoding)) &#123;
            encoding = null;
        &#125;
        String[] locations = propertySource.getStringArray(&quot;value&quot;);
        Assert.isTrue(locations.length &gt; 0, &quot;At least one @PropertySource(value) location is required&quot;);
        boolean ignoreResourceNotFound = propertySource.getBoolean(&quot;ignoreResourceNotFound&quot;);

        Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(&quot;factory&quot;);
        PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?
                DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));

        for (String location : locations) &#123;
            try &#123;
                String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);
                Resource resource = this.resourceLoader.getResource(resolvedLocation);
                addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));
            &#125;
            catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) &#123;
                // Placeholders not resolvable or resource not found when trying to open it
                if (ignoreResourceNotFound) &#123;
                    if (logger.isInfoEnabled()) &#123;
                        logger.info(&quot;Properties location [&quot; + location + &quot;] not resolvable: &quot; + ex.getMessage());
                    &#125;
                &#125;
                else &#123;
                    throw ex;
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<ul>
<li><strong>@ComponentScan</strong></li>
</ul>
<p>遍历这个Configuration的所有的@ComponentScan注解，对每一个ComponentScan进行扫描，找出所有注册的Bean存放在Set<BeanDefinitionHolder> scannedBeanDefinitions里，然后对这个Set遍历，然后逐个检查是否是Configuration候选类，是的话，递归调用parse方法进行解析。请看代码：</p>
<pre><code class="java">// Process any @ComponentScan annotations
        Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
                sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
        if (!componentScans.isEmpty() &amp;&amp;
                !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;
            for (AnnotationAttributes componentScan : componentScans) &#123;
                // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
                Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
                        this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
                // Check the set of scanned definitions for any further config classes and parse recursively if needed
                for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;
                    BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                    if (bdCand == null) &#123;
                        bdCand = holder.getBeanDefinition();
                    &#125;
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;
                        parse(bdCand.getBeanClassName(), holder.getBeanName());
                    &#125;
                &#125;
            &#125;
        &#125;
</code></pre>
<ul>
<li><strong>@Import</strong> 同样是先处理死循环的情形，然后根据import导入的class的类型，分为实现了接口ImportSelector、实现了接口ImportBeanDefinitionRegistrar、两者都没实现等三种情况进行解析，其中ImportSelector里，还划分出延迟导入的类型，实现了DeferredImportSelector接口，这个接口也是继承了ImportSelector。关于这几个接口的细节不是本文讨论内容，请移步：<a target="_blank" rel="noopener" href="https://my.oschina.net/u/3058881/blog/1673957">https://my.oschina.net/u/3058881/blog/1673957</a>,延迟导入接口资料比较少，后文还会提及。</li>
</ul>
<pre><code class="java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
            Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) &#123;

        if (importCandidates.isEmpty()) &#123;
            return;
        &#125;

        if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;
            this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
        &#125;
        else &#123;
            this.importStack.push(configClass);
            try &#123;
                for (SourceClass candidate : importCandidates) &#123;
                    if (candidate.isAssignable(ImportSelector.class)) &#123;
                        // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
                        Class&lt;?&gt; candidateClass = candidate.loadClass();
                        ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
                        ParserStrategyUtils.invokeAwareMethods(
                                selector, this.environment, this.resourceLoader, this.registry);
                        if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) &#123;
                            this.deferredImportSelectors.add(
                                    new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
                        &#125;
                        else &#123;
                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                            Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
                            processImports(configClass, currentSourceClass, importSourceClasses, false);
                        &#125;
                    &#125;
                    else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;
                        // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
                        // delegate to it to register additional bean definitions
                        Class&lt;?&gt; candidateClass = candidate.loadClass();
                        ImportBeanDefinitionRegistrar registrar =
                                BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
                        ParserStrategyUtils.invokeAwareMethods(
                                registrar, this.environment, this.resourceLoader, this.registry);
                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                    &#125;
                    else &#123;
                        // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
                        // process it as an @Configuration class
                        this.importStack.registerImport(
                                currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                        processConfigurationClass(candidate.asConfigClass(configClass));
                    &#125;
                &#125;
            &#125;
            catch (BeanDefinitionStoreException ex) &#123;
                throw ex;
            &#125;
            catch (Throwable ex) &#123;
                throw new BeanDefinitionStoreException(
                        &quot;Failed to process import candidates for configuration class [&quot; +
                        configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
            &#125;
            finally &#123;
                this.importStack.pop();
            &#125;
        &#125;
    &#125;
</code></pre>
<ul>
<li><strong>@ImportResource</strong> 非常简单，直接看代码：</li>
</ul>
<pre><code class="java">// Process any @ImportResource annotations
        AnnotationAttributes importResource =
                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
        if (importResource != null) &#123;
            String[] resources = importResource.getStringArray(&quot;locations&quot;);
            Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
            for (String resource : resources) &#123;
                String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
                configClass.addImportedResource(resolvedResource, readerClass);
            &#125;
        &#125;
</code></pre>
<ul>
<li><strong>@Bean methods</strong> 先获取所有的带有@Bean注释的方法，然后全部添加到configClass里，这里并没有实例化。再看看获取方法的代码，可以看到，方法里尝试使用Java字节码解析技术ASM解析获取所有的方法，然后对从AnnotationMetadata里获得的方法进行简单的过滤 ：</li>
</ul>
<pre><code class="java">    /**
     * Retrieve the metadata for all &lt;code&gt;@Bean&lt;/code&gt; methods.
     */
    private Set&lt;MethodMetadata&gt; retrieveBeanMethodMetadata(SourceClass sourceClass) &#123;
        AnnotationMetadata original = sourceClass.getMetadata();
        Set&lt;MethodMetadata&gt; beanMethods = original.getAnnotatedMethods(Bean.class.getName());
        if (beanMethods.size() &gt; 1 &amp;&amp; original instanceof StandardAnnotationMetadata) &#123;
            // Try reading the class file via ASM for deterministic declaration order...
            // Unfortunately, the JVM&#39;s standard reflection returns methods in arbitrary
            // order, even between different runs of the same application on the same JVM.
            try &#123;
                AnnotationMetadata asm =
                        this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata();
                Set&lt;MethodMetadata&gt; asmMethods = asm.getAnnotatedMethods(Bean.class.getName());
                if (asmMethods.size() &gt;= beanMethods.size()) &#123;
                    Set&lt;MethodMetadata&gt; selectedMethods = new LinkedHashSet&lt;&gt;(asmMethods.size());
                    for (MethodMetadata asmMethod : asmMethods) &#123;
                        for (MethodMetadata beanMethod : beanMethods) &#123;
                            if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) &#123;
                                selectedMethods.add(beanMethod);
                                break;
                            &#125;
                        &#125;
                    &#125;
                    if (selectedMethods.size() == beanMethods.size()) &#123;
                        // All reflection-detected methods found in ASM method set -&gt; proceed
                        beanMethods = selectedMethods;
                    &#125;
                &#125;
            &#125;
            catch (IOException ex) &#123;
                logger.debug(&quot;Failed to read class file via ASM for determining @Bean method order&quot;, ex);
                // No worries, let&#39;s continue with the reflection metadata we started with...
            &#125;
        &#125;
        return beanMethods;
    &#125;
</code></pre>
<ul>
<li><strong>接口方法</strong> 遍历实现的所有接口，或者这些接口的方法中被@Bean注解的方法，同样添加到configclass的beanMethods中。</li>
</ul>
<pre><code class="java">/**
     * Register default methods on interfaces implemented by the configuration class.
     */
    private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException &#123;
        for (SourceClass ifc : sourceClass.getInterfaces()) &#123;
            Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(ifc);
            for (MethodMetadata methodMetadata : beanMethods) &#123;
                if (!methodMetadata.isAbstract()) &#123;
                    // A default method or other concrete method on a Java 8+ interface...
                    configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
                &#125;
            &#125;
            processInterfaces(configClass, ifc);
        &#125;
    &#125;
</code></pre>
<ul>
<li><strong>超类</strong> 也是很简单，递归遍历超类，排除java内部类。</li>
</ul>
<pre><code class="java">// Process superclass, if any
        if (sourceClass.getMetadata().hasSuperClass()) &#123;
            String superclass = sourceClass.getMetadata().getSuperClassName();
            if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;
                    !this.knownSuperclasses.containsKey(superclass)) &#123;
                this.knownSuperclasses.put(superclass, configClass);
                // Superclass found, return its annotation metadata and recurse
                return sourceClass.getSuperClass();
            &#125;
        &#125;
</code></pre>
<p>好了，processConfigurationClass分析得差不多了，回过头，重新回到ConfigurationClassParser#parse方法，可以看到，三个分叉的parse结束之后，我们其实已经完成了Configuration类的解析工作，最后还有一步processDeferredImportSelectors(),请看：</p>
<pre><code class="java">private void processDeferredImportSelectors() &#123;
        List&lt;DeferredImportSelectorHolder&gt; deferredImports = this.deferredImportSelectors;
        this.deferredImportSelectors = null;
        if (deferredImports == null) &#123;
            return;
        &#125;

        deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);
        Map&lt;Object, DeferredImportSelectorGrouping&gt; groupings = new LinkedHashMap&lt;&gt;();
        Map&lt;AnnotationMetadata, ConfigurationClass&gt; configurationClasses = new HashMap&lt;&gt;();
        for (DeferredImportSelectorHolder deferredImport : deferredImports) &#123;
            Class&lt;? extends Group&gt; group = deferredImport.getImportSelector().getImportGroup();
            DeferredImportSelectorGrouping grouping = groupings.computeIfAbsent(
                    (group == null ? deferredImport : group),
                    (key) -&gt; new DeferredImportSelectorGrouping(createGroup(group)));
            grouping.add(deferredImport);
            configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),
                    deferredImport.getConfigurationClass());
        &#125;
        for (DeferredImportSelectorGrouping grouping : groupings.values()) &#123;
            grouping.getImports().forEach((entry) -&gt; &#123;
                ConfigurationClass configurationClass = configurationClasses.get(
                        entry.getMetadata());
                try &#123;
                    processImports(configurationClass, asSourceClass(configurationClass),
                            asSourceClasses(entry.getImportClassName()), false);
                &#125;
                catch (BeanDefinitionStoreException ex) &#123;
                    throw ex;
                &#125;
                catch (Throwable ex) &#123;
                    throw new BeanDefinitionStoreException(
                            &quot;Failed to process import candidates for configuration class [&quot; +
                                    configurationClass.getMetadata().getClassName() + &quot;]&quot;, ex);
                &#125;
            &#125;);
        &#125;
    &#125;
</code></pre>
<p>这里处理的就是上文提及的延迟导入。这里先将deferredImportSelectors分组，然后各组分别调用processImports，为啥要分组，这个问题先mark下。这里有个小细节要注意下，就是this.deferredImportSelectors &#x3D; null，下边会提到。</p>
<p>继续看processImports方法,这个方法上文其实已经分析过了，这里只看一小部分代码：</p>
<pre><code class="java">
    if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) &#123;
        this.deferredImportSelectors.add(
                new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
    &#125;
    else &#123;
        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);
        processImports(configClass, currentSourceClass, importSourceClasses, false);
    &#125;
</code></pre>
<p>可以看到，将deferredImportSelectors置为null在这里发挥了作用，代码逻辑走进了else里。在else里不断地递归下去。</p>
<p>到这里，ConfigurationClassParser#parse已经分析完毕，重新回到ConfigurationClassPostProcessor#processConfigBeanDefinitions。</p>
<p>接下来，就是parser.validate()。这里主要是做一些校验工作，比如：</p>
<ul>
<li>@Configuration 注解的Bean不能被final关键字修饰</li>
<li>@Bean修饰的静态方法，不用校验，没有限制</li>
<li>@Configuration 注解的Bean里的@Bean方法必须是可重写的（不能被static、final、private 修饰)</li>
</ul>
<p>校验结束后，就开始加载beanDefinitions ：</p>
<pre><code class="java">        // Read the model and create bean definitions based on its content
        if (this.reader == null) &#123;
            this.reader = new ConfigurationClassBeanDefinitionReader(
                    registry, this.sourceExtractor, this.resourceLoader, this.environment,
                    this.importBeanNameGenerator, parser.getImportRegistry());
        &#125;
        this.reader.loadBeanDefinitions(configClasses);
        alreadyParsed.addAll(configClasses);
</code></pre>
<p>从loadBeanDefinitions进去，可以看到：</p>
<pre><code class="java">/**
     * Read a particular &#123;@link ConfigurationClass&#125;, registering bean definitions
     * for the class itself and all of its &#123;@link Bean&#125; methods.
     */
    private void loadBeanDefinitionsForConfigurationClass(
            ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) &#123;

        if (trackedConditionEvaluator.shouldSkip(configClass)) &#123;
            String beanName = configClass.getBeanName();
            if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) &#123;
                this.registry.removeBeanDefinition(beanName);
            &#125;
            this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
            return;
        &#125;

        if (configClass.isImported()) &#123;
            registerBeanDefinitionForImportedConfigurationClass(configClass);
        &#125;
        for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;
            loadBeanDefinitionsForBeanMethod(beanMethod);
        &#125;

        loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
        loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
    &#125;
</code></pre>
<p>这里分为几种情况进行处理：1.import的；2.@Bean方法注入的；3.资源文件导入的(groovy、xml、properties)；4.通过ImportBeanDefinitionRegistrar导入的。</p>
<p>这几个情况都是注册了bean，但貌似都没有实例化。好吧，不细细展开了。另外，ImportBeanDefinitionRegistrar接口动态加载bean这个地方以后文章再展开，mark一下。</p>
<p>好了，回到ConfigurationClassPostProcessor#processConfigBeanDefinitions，看到最后跳出do…while…后，注册了一个单例ConfigurationClassPostProcessor.importRegistry,干啥用的不知道，以后会懂，mark!</p>
<p>最后还有个清理缓存的步骤，到这里第一个重要方法invokeBeanDefinitionRegistryPostProcessors，已经分析完毕。总体看，就是为了解析Configuration类的。</p>
<h4 id="重要方法2：invokeBeanFactoryPostProcessors"><a href="#重要方法2：invokeBeanFactoryPostProcessors" class="headerlink" title="重要方法2：invokeBeanFactoryPostProcessors"></a>重要方法2：invokeBeanFactoryPostProcessors</h4><p>先看方法入口：</p>
<pre><code class="java">/**
     * Invoke the given BeanFactoryPostProcessor beans.
     */
    private static void invokeBeanFactoryPostProcessors(
            Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) &#123;

        for (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;
            postProcessor.postProcessBeanFactory(beanFactory);
        &#125;
    &#125;
</code></pre>
<p>看到这个方法处理的是BeanFactoryPostProcessor的子类，对所有的postProcessors，都有调用postProcessBeanFactory方法。这里边会有好几个子类，部分子类的postProcessBeanFactory是空方法，这里主要看看ConfigurationClassPostProcessor类好了。</p>
<pre><code class="java">
    /**
     * Prepare the Configuration classes for servicing bean requests at runtime
     * by replacing them with CGLIB-enhanced subclasses.
     */
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;
        int factoryId = System.identityHashCode(beanFactory);
        if (this.factoriesPostProcessed.contains(factoryId)) &#123;
            throw new IllegalStateException(
                    &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory);
        &#125;
        this.factoriesPostProcessed.add(factoryId);
        if (!this.registriesPostProcessed.contains(factoryId)) &#123;
            // BeanDefinitionRegistryPostProcessor hook apparently not supported...
            // Simply call processConfigurationClasses lazily at this point then.
            processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
        &#125;

        enhanceConfigurationClasses(beanFactory);
        beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
    &#125;
</code></pre>
<p>一开始也是检查是否处理过这个processor，没处理过的话，进入processConfigBeanDefinitions方法，这里跟上边的postProcessBeanDefinitionRegistry是一模一样的，不展开说了。</p>
<p>处理完之后到了enhanceConfigurationClasses(beanFactory) 展开看看：</p>
<pre><code class="java">
/**
     * Post-processes a BeanFactory in search of Configuration class BeanDefinitions;
     * any candidates are then enhanced by a &#123;@link ConfigurationClassEnhancer&#125;.
     * Candidate status is determined by BeanDefinition attribute metadata.
     * @see ConfigurationClassEnhancer
     */
    public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123;
        Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;();
        for (String beanName : beanFactory.getBeanDefinitionNames()) &#123;
            BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
            if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;
                if (!(beanDef instanceof AbstractBeanDefinition)) &#123;
                    throw new BeanDefinitionStoreException(&quot;Cannot enhance @Configuration bean definition &#39;&quot; +
                            beanName + &quot;&#39; since it is not stored in an AbstractBeanDefinition subclass&quot;);
                &#125;
                else if (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;
                    logger.warn(&quot;Cannot enhance @Configuration bean definition &#39;&quot; + beanName +
                            &quot;&#39; since its singleton instance has been created too early. The typical cause &quot; +
                            &quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot; +
                            &quot;return type: Consider declaring such methods as &#39;static&#39;.&quot;);
                &#125;
                configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
            &#125;
        &#125;
        if (configBeanDefs.isEmpty()) &#123;
            // nothing to enhance -&gt; return immediately
            return;
        &#125;

        ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
        for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;
            AbstractBeanDefinition beanDef = entry.getValue();
            // If a @Configuration class gets proxied, always proxy the target class
            beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
            try &#123;
                // Set enhanced subclass of the user-specified bean class
                Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);
                if (configClass != null) &#123;
                    Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
                    if (configClass != enhancedClass) &#123;
                        if (logger.isDebugEnabled()) &#123;
                            logger.debug(String.format(&quot;Replacing bean definition &#39;%s&#39; existing class &#39;%s&#39; with &quot; +
                                    &quot;enhanced class &#39;%s&#39;&quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));
                        &#125;
                        beanDef.setBeanClass(enhancedClass);
                    &#125;
                &#125;
            &#125;
            catch (Throwable ex) &#123;
                throw new IllegalStateException(&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);
            &#125;
        &#125;
    &#125;

</code></pre>
<p>看起来时用CGLIB技术对bean进行增强的，这是个知识点，以后文章展开，mark.</p>
<p>回来后，添加了一个BeanPostProcessor，为</p>
<pre><code class="java">beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
</code></pre>
<p>好吧，第二个方法就这样结束，感觉越来越水了。</p>
<p>这两个重要方法是我们在PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors中展开的，现在分析完毕，我们重新回到调用处继续分析。调用处为AbstractApplicationContext#invokeBeanFactoryPostProcessors。回顾下代码：</p>
<pre><code class="java">/**
     * Instantiate and invoke all registered BeanFactoryPostProcessor beans,
     * respecting explicit order if given.
     * &lt;p&gt;Must be called before singleton instantiation.
     */
    protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;
        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

        // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
        // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
        if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        &#125;
    &#125;
</code></pre>
<p>这段代码已经在上文分析过了，继续回到上一层调用点。哦哦，已经回到了refresh方法。好的，invokeBeanFactoryPostProcessors过程分析结束。</p>
<h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h3><p>从注解看，这个方法是注册那些拦截bean创建过程的bean processors。进入方法：</p>
<pre><code class="java">/**
     * Instantiate and invoke all registered BeanPostProcessor beans,
     * respecting explicit order if given.
     * &lt;p&gt;Must be called before any instantiation of application beans.
     */
    protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;
        PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
    &#125;
</code></pre>
<p>注释说到，实例化并且调用所有被注册的beanPostProcessor类型bean，并按照指定的顺序。这个方法一定要在应用bean实例化之前被调用。</p>
<p>再次进入这个PostProcessorRegistrationDelegate类看看代码：</p>
<pre><code class="java">public static void registerBeanPostProcessors(
            ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;

        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

        // Register BeanPostProcessorChecker that logs an info message when
        // a bean is created during BeanPostProcessor instantiation, i.e. when
        // a bean is not eligible for getting processed by all BeanPostProcessors.
        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
        beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

        // Separate between BeanPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
        for (String ppName : postProcessorNames) &#123;
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;
                BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
                priorityOrderedPostProcessors.add(pp);
                if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                    internalPostProcessors.add(pp);
                &#125;
            &#125;
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;
                orderedPostProcessorNames.add(ppName);
            &#125;
            else &#123;
                nonOrderedPostProcessorNames.add(ppName);
            &#125;
        &#125;

        // First, register the BeanPostProcessors that implement PriorityOrdered.
        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
        registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

        // Next, register the BeanPostProcessors that implement Ordered.
        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : orderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            orderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        sortPostProcessors(orderedPostProcessors, beanFactory);
        registerBeanPostProcessors(beanFactory, orderedPostProcessors);

        // Now, register all regular BeanPostProcessors.
        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : nonOrderedPostProcessorNames) &#123;
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            nonOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;
                internalPostProcessors.add(pp);
            &#125;
        &#125;
        registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

        // Finally, re-register all internal BeanPostProcessors.
        sortPostProcessors(internalPostProcessors, beanFactory);
        registerBeanPostProcessors(beanFactory, internalPostProcessors);

        // Re-register post-processor for detecting inner beans as ApplicationListeners,
        // moving it to the end of the processor chain (for picking up proxies etc).
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
    &#125;
</code></pre>
<p>这个方法主要做的事情有几件：</p>
<ul>
<li>捞出所有的实现了BeanPostProcessor接口的Bean，然后注册一个新的BeanPostProcessorChecker，也是实现了BeanPostProcessor接口的实例</li>
<li>然后将BeanPostProcessor分为四类，分别是priorityOrderedPostProcessors、orderedPostProcessorNames、nonOrderedPostProcessorNames以及internalPostProcessors。需要排序的就排序，最后都是调用registerBeanPostProcessors进行注册</li>
<li>最后再注册一个ApplicationListenerDetector，实现了MergedBeanDefinitionPostProcessor接口</li>
</ul>
<p>然后所谓的注册环节，其实只是在beanFactory里做简单的add操作。</p>
<pre><code class="java">@Override
    public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) &#123;
        Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);
        this.beanPostProcessors.remove(beanPostProcessor);
        this.beanPostProcessors.add(beanPostProcessor);
        if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) &#123;
            this.hasInstantiationAwareBeanPostProcessors = true;
        &#125;
        if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) &#123;
            this.hasDestructionAwareBeanPostProcessors = true;
        &#125;
    &#125;
</code></pre>
<h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h3><p>MessageSource是spring提供的一个接口，以用于支持信息的国际化和包含参数的信息的替换。国际化也是一个知识拓展点，Mark之。先简单看看：</p>
<pre><code class="java">/**
     * Initialize the MessageSource.
     * Use parent&#39;s if none defined in this context.
     */
    protected void initMessageSource() &#123;
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;
            this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
            // Make MessageSource aware of parent MessageSource.
            if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) &#123;
                HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
                if (hms.getParentMessageSource() == null) &#123;
                    // Only set parent context as parent MessageSource if no parent MessageSource
                    // registered already.
                    hms.setParentMessageSource(getInternalParentMessageSource());
                &#125;
            &#125;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);
            &#125;
        &#125;
        else &#123;
            // Use empty MessageSource to be able to accept getMessage calls.
            DelegatingMessageSource dms = new DelegatingMessageSource();
            dms.setParentMessageSource(getInternalParentMessageSource());
            this.messageSource = dms;
            beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Unable to locate MessageSource with name &#39;&quot; + MESSAGE_SOURCE_BEAN_NAME +
                        &quot;&#39;: using default [&quot; + this.messageSource + &quot;]&quot;);
            &#125;
        &#125;
    &#125;
</code></pre>
<p>initMessageSource 主要做的事情是：</p>
<ul>
<li>先去beanFactory看有没有注册一个名为messageSource的bean，如果存在，取出这个bean作为上下文的this.messageSource。</li>
<li>如果这是一个HierarchicalMessageSource，则会在父容器存在的情况下取父容器对应的messageSource作为当前messageSource的parentMessageSource</li>
<li>如果当前bean容器中不存在beanName为messageSource的bean，则会生成一个DelegatingMessageSource来作为当前的MessageSource。DelegatingMessageSource基本算是对MessageSource的一个空的实现，在对应父容器的messageSource存在时就使用父容器的messageSource处理，否则就不处理，具体可以参考Spring的API文档或查看DelegatingMessageSource的源码。</li>
</ul>
<p>国际化的更多内容，以后通过文章拓展，mark。可参考<a target="_blank" rel="noopener" href="http://elim.iteye.com/blog/2392583">国际化MessageSource</a></p>
<h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h3><p>初始化事件广播器，跟上一步类似，去beanfactory里看有没有名叫applicationEventMulticaster的bean。如果存在，取出它作为上下文的事件广播器。如果不存在，则新建一个SimpleApplicationEventMulticaster作为上下文事件广播器。</p>
<pre><code class="java">/**
     * Initialize the ApplicationEventMulticaster.
     * Uses SimpleApplicationEventMulticaster if none defined in the context.
     * @see org.springframework.context.event.SimpleApplicationEventMulticaster
     */
    protected void initApplicationEventMulticaster() &#123;
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;
            this.applicationEventMulticaster =
                    beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Using ApplicationEventMulticaster [&quot; + this.applicationEventMulticaster + &quot;]&quot;);
            &#125;
        &#125;
        else &#123;
            this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
            beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Unable to locate ApplicationEventMulticaster with name &#39;&quot; +
                        APPLICATION_EVENT_MULTICASTER_BEAN_NAME +
                        &quot;&#39;: using default [&quot; + this.applicationEventMulticaster + &quot;]&quot;);
            &#125;
        &#125;
    &#125;
</code></pre>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/caihaijiang/article/details/7460888">Spring事件体系</a></p>
<h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>onRefresh的实现在类中，代码如下：</p>
<pre><code class="java">@Override
    protected void onRefresh() &#123;
        super.onRefresh();
        try &#123;
            createWebServer();
        &#125;
        catch (Throwable ex) &#123;
            throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);
        &#125;
    &#125;
</code></pre>
<p>第一句的super.onRefresh()先调用父类的方法，主要是做了一个初始化主题的动作,spring主题用的比较少，这里不展开，mark ：</p>
<pre><code class="java">@Override
    protected void onRefresh() &#123;
        this.themeSource = UiApplicationContextUtils.initThemeSource(this);
    &#125;
</code></pre>
<p>第二步做的是初始化Servlet容器的动作，支持3种内置的Servlet容器：Tomcat、Jetty、Undertow。这里初始化的是Tomcat类型的容器</p>
<pre><code class="java">private void createWebServer() &#123;
        WebServer webServer = this.webServer;
        ServletContext servletContext = getServletContext();
        if (webServer == null &amp;&amp; servletContext == null) &#123;
            ServletWebServerFactory factory = getWebServerFactory();
            this.webServer = factory.getWebServer(getSelfInitializer());
        &#125;
        else if (servletContext != null) &#123;
            try &#123;
                getSelfInitializer().onStartup(servletContext);
            &#125;
            catch (ServletException ex) &#123;
                throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;,
                        ex);
            &#125;
        &#125;
        initPropertySources();
    &#125;
</code></pre>
<h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h3><p>顾名思义，这个方法是用于注册监听器的，这里将之前上下文里的ApplicationListners全部注册到了事件广播器里，同时也取beanfactory里获取所有实现了ApplicationListener接口的bean的名字，添加到事件广播器里，但并没有初始化这些bean。注释说到，是为了等待post-processors应用他们，不是很懂，mark。然后广播多个early application events。</p>
<pre><code class="java">/**
     * Add beans that implement ApplicationListener as listeners.
     * Doesn&#39;t affect other listeners, which can be added without being beans.
     */
    protected void registerListeners() &#123;
        // Register statically specified listeners first.
        for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;
            getApplicationEventMulticaster().addApplicationListener(listener);
        &#125;

        // Do not initialize FactoryBeans here: We need to leave all regular beans
        // uninitialized to let post-processors apply to them!
        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
        for (String listenerBeanName : listenerBeanNames) &#123;
            getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
        &#125;

        // Publish early application events now that we finally have a multicaster...
        Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;
        this.earlyApplicationEvents = null;
        if (earlyEventsToProcess != null) &#123;
            for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;
                getApplicationEventMulticaster().multicastEvent(earlyEvent);
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h3><p>完成上下文beanFactory的初始化，初始化所有剩余的单例bean。</p>
<pre><code class="java">/**
     * Finish the initialization of this context&#39;s bean factory,
     * initializing all remaining singleton beans.
     */
    protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;
        // Initialize conversion service for this context.
        if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
                beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;
            beanFactory.setConversionService(
                    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
        &#125;

        // Register a default embedded value resolver if no bean post-processor
        // (such as a PropertyPlaceholderConfigurer bean) registered any before:
        // at this point, primarily for resolution in annotation attribute values.
        if (!beanFactory.hasEmbeddedValueResolver()) &#123;
            beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
        &#125;

        // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        for (String weaverAwareName : weaverAwareNames) &#123;
            getBean(weaverAwareName);
        &#125;

        // Stop using the temporary ClassLoader for type matching.
        beanFactory.setTempClassLoader(null);

        // Allow for caching all bean definition metadata, not expecting further changes.
        beanFactory.freezeConfiguration();

        // Instantiate all remaining (non-lazy-init) singletons.
        beanFactory.preInstantiateSingletons();
    &#125;
</code></pre>
<ul>
<li>先查看beanFactory是否包含名为conversionService的bean，如果存在捞出来设置到beanFactory里。ConversionService是用于做类型转换的，拓展点 mark。</li>
<li>其他几步不知道干嘛的，先不管。</li>
<li>beanFactory.preInstantiateSingletons()开始实例化所有剩余的单例bean.</li>
</ul>
<p>对preInstantiateSingletons展开：</p>
<pre><code class="java">@Override
    public void preInstantiateSingletons() throws BeansException &#123;
        if (this.logger.isDebugEnabled()) &#123;
            this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);
        &#125;

        // Iterate over a copy to allow for init methods which in turn register new bean definitions.
        // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
        List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);

        // Trigger initialization of all non-lazy singleton beans...
        for (String beanName : beanNames) &#123;
            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
            if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;
                if (isFactoryBean(beanName)) &#123;
                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                    if (bean instanceof FactoryBean) &#123;
                        final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
                        boolean isEagerInit;
                        if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;
                            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                                            ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                                    getAccessControlContext());
                        &#125;
                        else &#123;
                            isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                                    ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                        &#125;
                        if (isEagerInit) &#123;
                            getBean(beanName);
                        &#125;
                    &#125;
                &#125;
                else &#123;
                    getBean(beanName);
                &#125;
            &#125;
        &#125;

        // Trigger post-initialization callback for all applicable beans...
        for (String beanName : beanNames) &#123;
            Object singletonInstance = getSingleton(beanName);
            if (singletonInstance instanceof SmartInitializingSingleton) &#123;
                final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
                if (System.getSecurityManager() != null) &#123;
                    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;
                        smartSingleton.afterSingletonsInstantiated();
                        return null;
                    &#125;, getAccessControlContext());
                &#125;
                else &#123;
                    smartSingleton.afterSingletonsInstantiated();
                &#125;
            &#125;
        &#125;
    &#125;

</code></pre>
<p>方法一开始捞出全部的beanNames,对于这些bean需要满足三个条件才能进行初始化：不是抽象类、单例、非懒加载。然后接着首先判断一下Bean是否FactoryBean的实现，接着判断Bean是否SmartFactoryBean的实现。这部分是Java开发基本用不到，不作展开。下边着重看下getBean方法，getBean方法最终调用的是DefaultListableBeanFactory的父类AbstractBeanFactory类的doGetBean方法，这个方法比较长，慢慢分析:</p>
<pre><code class="java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
            @Nullable final Object[] args, boolean typeCheckOnly) 
</code></pre>
<p>先看方法定义：<br><strong>name</strong> 需要获取的bean名字<br><strong>requiredType</strong> 要检索的bean所需的类型<br><strong>args</strong> 使用显式参数创建bean 实例 时使用的参数（仅在创建新实例时应用，而不是在检索现有实例时应用）<br><strong>typeCheckOnly</strong> 是否为了类型检查而获取实例，而不是实际使用</p>
<pre><code class="java">// Eagerly check singleton cache for manually registered singletons.
Object sharedInstance = getSingleton(beanName);
if (sharedInstance != null &amp;&amp; args == null) &#123;
    if (logger.isDebugEnabled()) &#123;
        if (isSingletonCurrentlyInCreation(beanName)) &#123;
            logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +
                    &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);
        &#125;
        else &#123;
            logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);
        &#125;
    &#125;
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
&#125;
</code></pre>
<p>getSingleton(beanName)，一开始先通过这个方法检查是否已经手动注册过这个bean,然后进入了getObjectForBeanInstance方法里，在里边会判断这个bean是一个普通的bean还是一个FactoryBean。如果是普通bean,直接返回，但如果是FactoryBean的话，情况比较复杂，跳过之。</p>
<pre><code class="java">if (isPrototypeCurrentlyInCreation(beanName)) &#123;
    throw new BeanCurrentlyInCreationException(beanName);
&#125;
</code></pre>
<p>但如果之前没有注册过这个bean，先检查这个bean是不是正在创建中（isPrototypeCurrentlyInCreation），如果是的话，直接抛异常BeanCurrentlyInCreationException。</p>
<pre><code class="java">// Check if bean definition exists in this factory.
BeanFactory parentBeanFactory = getParentBeanFactory();
if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;
    // Not found -&gt; check parent.
    String nameToLookup = originalBeanName(name);
    if (parentBeanFactory instanceof AbstractBeanFactory) &#123;
        return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                nameToLookup, requiredType, args, typeCheckOnly);
    &#125;
    else if (args != null) &#123;
        // Delegation to parent with explicit args.
        return (T) parentBeanFactory.getBean(nameToLookup, args);
    &#125;
    else &#123;
        // No args -&gt; delegate to standard getBean method.
        return parentBeanFactory.getBean(nameToLookup, requiredType);
    &#125;
&#125;
</code></pre>
<p>再检查父类的BeanFactory是否有注册过这个bean，尝试获取并且返回。</p>
<pre><code class="java">if (!typeCheckOnly) &#123;
    markBeanAsCreated(beanName);
&#125;
</code></pre>
<p>如果不仅仅是作类型检查的话，标记这个bean已经创建。</p>
<pre><code class="java">final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
checkMergedBeanDefinition(mbd, beanName, args);

// Guarantee initialization of beans that the current bean depends on.
String[] dependsOn = mbd.getDependsOn();
if (dependsOn != null) &#123;
    for (String dep : dependsOn) &#123;
        if (isDependent(beanName, dep)) &#123;
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);
        &#125;
        registerDependentBean(dep, beanName);
        try &#123;
            getBean(dep);
        &#125;
        catch (NoSuchBeanDefinitionException ex) &#123;
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);
        &#125;
    &#125;
&#125;
</code></pre>
<p>这里检查这个bean依赖的其他bean，然后递归进去getBean。这里的循环依赖检测看着像是写反了，有点疑惑暂时不深究 mark。</p>
<pre><code class="java">// Create bean instance.
if (mbd.isSingleton()) &#123;
    sharedInstance = getSingleton(beanName, () -&gt; &#123;
        try &#123;
            return createBean(beanName, mbd, args);
        &#125;
        catch (BeansException ex) &#123;
            // Explicitly remove instance from singleton cache: It might have been put there
            // eagerly by the creation process, to allow for circular reference resolution.
            // Also remove any beans that received a temporary reference to the bean.
            destroySingleton(beanName);
            throw ex;
        &#125;
    &#125;);
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
&#125;
</code></pre>
<p>单例创建bean，getSingleton方法里会回调getObject()方法，其实就是调用createBean(beanName, mbd, args)方法。<br>createBean往下太底层了，对普通开发者没多大影响，不分析下去了。</p>
<pre><code class="java">if (mbd.isPrototype()) &#123;
    // It&#39;s a prototype -&gt; create a new instance.
    Object prototypeInstance = null;
    try &#123;
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    &#125;
    finally &#123;
        afterPrototypeCreation(beanName);
    &#125;
    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
&#125;

else &#123;
    String scopeName = mbd.getScope();
    final Scope scope = this.scopes.get(scopeName);
    if (scope == null) &#123;
        throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);
    &#125;
    try &#123;
        Object scopedInstance = scope.get(beanName, () -&gt; &#123;
            beforePrototypeCreation(beanName);
            try &#123;
                return createBean(beanName, mbd, args);
            &#125;
            finally &#123;
                afterPrototypeCreation(beanName);
            &#125;
        &#125;);
        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
    &#125;
    catch (IllegalStateException ex) &#123;
        throw new BeanCreationException(beanName,
                &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +
                &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                ex);
    &#125;
&#125;
</code></pre>
<p>接着处理Prototype类型以及其他类型，过程都差不多，最后都是调用了createBean(beanName, mbd, args)。</p>
<h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h3><p>最后一步主要是清理缓存、刷新生命周期处理器、发布ContextRefreshedEvent事件等。</p>
<p><strong>总结：启动过程粗略地浏览了一遍，感觉只掌握了两三成，还需要继续深入研究。</strong></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 duval1024@gmail.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '0249fec24dcaf3532c31',
            clientSecret: '8ca1dd59f6b90d119d2206a05550f959dcc8e211',
            repo: 'baygeekarea_commet_area',
            owner: 'duval1024',
            admin: ['duval1024'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2024 Duval
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
