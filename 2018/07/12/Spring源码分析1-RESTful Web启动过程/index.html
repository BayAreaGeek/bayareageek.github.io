<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Spring源码分析1-RESTfulWeb启动过程 | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Spring框架用的很多了，但是没有深入研究过原理。因为对原理不了解，如果遇到复杂的应用情景，需要修改Spring源码；或者是奇怪的报错，需要通过源码来进行分析的时候，就只能束手无策了。所以现在开始正式阅读Spring源码，这是系列的第一篇，希望能坚持下去。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码分析1-RESTfulWeb启动过程">
<meta property="og:url" content="http://example.com/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-RESTful%20Web%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name">
<meta property="og:description" content="Spring框架用的很多了，但是没有深入研究过原理。因为对原理不了解，如果遇到复杂的应用情景，需要修改Spring源码；或者是奇怪的报错，需要通过源码来进行分析的时候，就只能束手无策了。所以现在开始正式阅读Spring源码，这是系列的第一篇，希望能坚持下去。">
<meta property="og:locale">
<meta property="article:published_time" content="2018-07-12T03:47:01.000Z">
<meta property="article:modified_time" content="2024-03-03T08:57:04.786Z">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Spring源码分析1-RESTful Web启动过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-RESTful%20Web%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-07-12T03:47:01.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Spring源码分析1-RESTfulWeb启动过程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Spring框架用的很多了，但是没有深入研究过原理。因为对原理不了解，如果遇到复杂的应用情景，需要修改Spring源码；或者是奇怪的报错，需要通过源码来进行分析的时候，就只能束手无策了。所以现在开始正式阅读Spring源码，这是系列的第一篇，希望能坚持下去。</p>
<span id="more"></span>
<p><strong>说在前边：本文是我阅读RestfulWeb启动过程写的流水账，瑕疵多多。</strong></p>
<p>第一篇先从最简单的情景入手，分析<strong>RESTful Web应用的启动加载流程</strong>。</p>
<h2 id="RESTfulWeb-应用"><a href="#RESTfulWeb-应用" class="headerlink" title="RESTfulWeb 应用"></a>RESTfulWeb 应用</h2><h3 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h3><p>REST（Representational State Transfer 表述性状态传输）是2000年的时候 Roy Fielding 在他的博士论文中的定义。REST是设计分布式系统的一种架构风格，它并不是一个标准，而是一系列的约束，包括：无状态、客户端&#x2F;服务端关系、统一接口等。REST跟HTTP不是强相关，但最常见的是这两者的关联。</p>
<p>其他文绉绉的定义请详见<a target="_blank" rel="noopener" href="http://spring.io/understanding/REST">Understanding REST</a></p>
<h3 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h3><p>使用spring教程提供的样例<a target="_blank" rel="noopener" href="https://github.com/spring-guides/gs-rest-service.git">gs-rest-service</a></p>
<ul>
<li>标准的spring boot application 入口</li>
</ul>
<pre><code class="java">@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<ul>
<li>暴露的controller</li>
</ul>
<pre><code class="java">@RestController
public class GreetingController &#123;
    private static final String template = &quot;Hello, %s!&quot;;
    private final AtomicLong counter = new AtomicLong();

    @RequestMapping(&quot;/greeting&quot;)
    public Greeting greeting(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;World&quot;) String name) &#123;
        return new Greeting(counter.incrementAndGet(),
                            String.format(template, name));
    &#125;
&#125;
</code></pre>
<p>好的，断点打好，debug启动，准备就绪。</p>
<p>欢迎来到Spring世界！</p>
<h2 id="构造SpringApplication"><a href="#构造SpringApplication" class="headerlink" title="构造SpringApplication"></a>构造SpringApplication</h2><pre><code class="java">SpringApplication.run(Application.class, args);
</code></pre>
<pre><code class="java">/**
     * Static helper that can be used to run a &#123;@link SpringApplication&#125; from the
     * specified source using default settings.
     * @param primarySource the primary source to load
     * @param args the application arguments (usually passed from a Java main method)
     * @return the running &#123;@link ApplicationContext&#125;
     */
    public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource,
            String... args) &#123;
        return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);
    &#125;
</code></pre>
<p>第一行代码是一个run，从这里进去后，可以看到这是SpringApplication提供的一个静态方法，这个Helper用于使用默认配置和指定的资源（这里是Application.class）来运行一个SpringApplication。简单说，就是按照默认方式构造一个SpringApplication！入参里还有个String[]args ,这其实就是寻常的main方法入参列表！</p>
<p>继续往下</p>
<pre><code class="java">/**
     * Create a new &#123;@link SpringApplication&#125; instance. The application context will load
     * beans from the specified primary sources (see &#123;@link SpringApplication class-level&#125;
     * documentation for details. The instance can be customized before calling
     * &#123;@link #run(String...)&#125;.
     * @param resourceLoader the resource loader to use
     * @param primarySources the primary bean sources
     * @see #run(Class, String[])
     * @see #setSources(Set)
     */
    @SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)
    public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;
        //资源加载器，这里传入的是Null
        this.resourceLoader = resourceLoader;
        //主资源不能为null，其实就是Application.class
        Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
        this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
        //推断web应用类型
        this.webApplicationType = deduceWebApplicationType();
        //获取初始化器实例们
        setInitializers((Collection) getSpringFactoriesInstances(
                ApplicationContextInitializer.class));
        //获取监听器实例们
        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
        //推断应用主类
        this.mainApplicationClass = deduceMainApplicationClass();
    &#125;
</code></pre>
<p>从上边的代码可以看到，构造SpringApplication的伟大使命，只要走四步！真是太容易了！请看：</p>
<h3 id="推断web应用类型"><a href="#推断web应用类型" class="headerlink" title="推断web应用类型"></a>推断web应用类型</h3><pre><code class="java">private WebApplicationType deduceWebApplicationType() &#123;
        if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null)
                &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) &#123;
            return WebApplicationType.REACTIVE;
        &#125;
        for (String className : WEB_ENVIRONMENT_CLASSES) &#123;
            if (!ClassUtils.isPresent(className, null)) &#123;
                return WebApplicationType.NONE;
            &#125;
        &#125;
        return WebApplicationType.SERVLET;
    &#125;
</code></pre>
<p>这里是根据某些特征类来确定web应用类型的。web应用类型居然有三种！</p>
<pre><code class="java">public enum WebApplicationType &#123;

    /**
     * The application should not run as a web application and should not start an embedded web server.
     *普通应用，不作为web应用运行，不需要启动内嵌web server
     */
    NONE,

    /**
     * The application should run as a servlet-based web application and should start an embedded servlet web server.
     * 基于servlet的web应用，需要启动内嵌web server
     */
    SERVLET,

    /**
     * The application should run as a reactive web application and should start an embedded reactive web server.
     *交互式web应用，需要启动内嵌web server
     */
    REACTIVE

&#125;
</code></pre>
<p>这三种有啥区别，我不知道！我也是一脸懵逼的！反正这次是SERVLET类型。他们的区别我以后肯定会知道的，先用小笔笔记下来。</p>
<h3 id="获取初始化器实例"><a href="#获取初始化器实例" class="headerlink" title="获取初始化器实例"></a>获取初始化器实例</h3><pre><code class="java">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;
        return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);
 &#125;

private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,
        Class&lt;?&gt;[] parameterTypes, Object... args) &#123;
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    // Use names and ensure unique to protect against duplicates
    //从SpringFactoriesLoader那里搞来一堆实例的类名
    Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(
            SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    //然后将那堆类名，通过classloader给实例化了！
    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,
            classLoader, args, names);
    AnnotationAwareOrderComparator.sort(instances);
    return instances;
&#125;
</code></pre>
<p>从上边可以看到，实例化之前，先去SpringFactoriesLoader弄来一个集合的类名。我们看看怎么弄出来的,逐层深入，看到：</p>
<pre><code class="java">//这里classloader不是空，正是上文获取的当前线程的classloader
//然后从FACTORIES_RESOURCE_LOCATION这个资源文件里获取了一把url
Enumeration&lt;URL&gt; urls = (classLoader != null ?
        classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
        ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
result = new LinkedMultiValueMap&lt;&gt;();
//将拿到的urls解析，获得一大把类名
while (urls.hasMoreElements()) &#123;
    URL url = urls.nextElement();
    UrlResource resource = new UrlResource(url);
    Properties properties = PropertiesLoaderUtils.loadProperties(resource);
    for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;
        List&lt;String&gt; factoryClassNames = Arrays.asList(
                StringUtils.commaDelimitedListToStringArray((String) entry.getValue()));
        result.addAll((String) entry.getKey(), factoryClassNames);
    &#125;
&#125;
cache.put(classLoader, result);
return result;
</code></pre>
<p>一看，呵！原来类名都是写死在文件FACTORIES_RESOURCE_LOCATION&#x3D;”META-INF&#x2F;spring.factories”里的。因为传入的classloader是当前线程ClassLoader，调用classLoader.getResources(String）的时候会把所有jar里的spring.factories都找出来。所以，其中一个spring.factories文件是在spring-boot包下的。打开瞧一瞧，里边东西还真不少：</p>
<pre><code class="xml"># PropertySource Loaders
org.springframework.boot.env.PropertySourceLoader=\
org.springframework.boot.env.PropertiesPropertySourceLoader,\
org.springframework.boot.env.YamlPropertySourceLoader

# Run Listeners
org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener

# Error Reporters
org.springframework.boot.SpringBootExceptionReporter=\
org.springframework.boot.diagnostics.FailureAnalyzers

# Application Context Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener

# Environment Post Processors
org.springframework.boot.env.EnvironmentPostProcessor=\
org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\
org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\
org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor

# Failure Analyzers
org.springframework.boot.diagnostics.FailureAnalyzer=\
org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.BindValidationFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.UnboundConfigurationPropertyFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyNameFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyValueFailureAnalyzer

# FailureAnalysisReporters
org.springframework.boot.diagnostics.FailureAnalysisReporter=\
org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter
</code></pre>
<p>当然这里就提示了我们，我们可以在自己的META-INF&#x2F;spring.factories，spring也可以找的到里边的listener，然后进行注册。</p>
<p>好了，刚说到拿到了上边那包类名了。继续 ~</p>
<pre><code class="java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;
        String factoryClassName = factoryClass.getName();
        return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
    &#125;
</code></pre>
<p>弱水三千，我只取一瓢。根据factoryClassName（这里是org.springframework.context.ApplicationContextInitializer)，我只取这包类名的一小部分。被取的也就是下边这几个：</p>
<pre><code class="xml">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer
org.springframework.boot.context.ContextIdApplicationContextInitializer
org.springframework.boot.context.config.DelegatingApplicationContextInitializer
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer
</code></pre>
<pre><code class="java">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,
                classLoader, args, names);
</code></pre>
<p>拿到类名了，这里就开始实例化了。</p>
<pre><code class="java">setInitializers((Collection) getSpringFactoriesInstances(
                ApplicationContextInitializer.class));
</code></pre>
<p>实例化完了，就结束了！设置到SpringApplication里以备后用！</p>
<h3 id="获取监听器实例"><a href="#获取监听器实例" class="headerlink" title="获取监听器实例"></a>获取监听器实例</h3><p>这一步跟获取初始化器是一模一样的，只有key不一样，这里用的key是org.springframework.context.ApplicationListener。好了，跳过跳过，拿到了一包监听器实例，如下：</p>
<pre><code class="xml">org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener
</code></pre>
<p>也设置到SpringApplication里以备后用！</p>
<h3 id="推断主类"><a href="#推断主类" class="headerlink" title="推断主类"></a>推断主类</h3><pre><code class="java">private Class&lt;?&gt; deduceMainApplicationClass() &#123;
        try &#123;
            StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
            for (StackTraceElement stackTraceElement : stackTrace) &#123;
                if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;
                    return Class.forName(stackTraceElement.getClassName());
                &#125;
            &#125;
        &#125;
        catch (ClassNotFoundException ex) &#123;
            // Swallow and continue
        &#125;
        return null;
    &#125;
</code></pre>
<p>取巧，从栈信息里，找到有个方法叫main的类的类名，然后返回。</p>
<h2 id="运行SpringApplication"><a href="#运行SpringApplication" class="headerlink" title="运行SpringApplication"></a>运行SpringApplication</h2><p>重头戏来了，进入run方法，可以看到非常复杂的一个方法。浏览一遍，然后我们一步一步分析</p>
<pre><code class="java">    /**
     * Run the Spring application, creating and refreshing a new
     * &#123;@link ApplicationContext&#125;.
     * @param args the application arguments (usually passed from a Java main method)
     * @return a running &#123;@link ApplicationContext&#125;
     */
    public ConfigurableApplicationContext run(String... args) &#123;
        //计时器开动
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        ConfigurableApplicationContext context = null;
        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
        //写入headless模式的环境变量 java.awt.headless=true
        configureHeadlessProperty();
        //获得运行时监听器，并调用start
        SpringApplicationRunListeners listeners = getRunListeners(args);
        listeners.starting();
        try &#123;
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(
                    args);
            //准备环境容器
            ConfigurableEnvironment environment = prepareEnvironment(listeners,
                    applicationArguments);
            configureIgnoreBeanInfo(environment);
            //准备环境容器
            Banner printedBanner = printBanner(environment);
            //创建上下文
            context = createApplicationContext();
            //构建exceptionReporters
            exceptionReporters = getSpringFactoriesInstances(
                    SpringBootExceptionReporter.class,
                    new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);
            //准备上下文
            prepareContext(context, environment, listeners, applicationArguments,
                    printedBanner);
            //刷新上下文
            refreshContext(context);
            //上下文后置处理
            afterRefresh(context, applicationArguments);
            //计时器停止
            stopWatch.stop();
            //打印启动日志
            if (this.logStartupInfo) &#123;
                new StartupInfoLogger(this.mainApplicationClass)
                        .logStarted(getApplicationLog(), stopWatch);
            &#125;
            //触发started事件
            listeners.started(context);
            //调用Runner
            callRunners(context, applicationArguments);
        &#125;
        catch (Throwable ex) &#123;
            handleRunFailure(context, ex, exceptionReporters, listeners);
            throw new IllegalStateException(ex);
        &#125;

        try &#123;
            listeners.running(context);
        &#125;
        catch (Throwable ex) &#123;
            handleRunFailure(context, ex, exceptionReporters, null);
            throw new IllegalStateException(ex);
        &#125;
        return context;
    &#125;
</code></pre>
<h3 id="打开HeadlessMode"><a href="#打开HeadlessMode" class="headerlink" title="打开HeadlessMode"></a>打开HeadlessMode</h3><p>一开始先打开headless模式，这个玩意儿没接触过，简单了解下。就是当设置了java.awt.headless&#x3D;true的时候，java应用就会默认进入headless模式。Headless模式是一个没有键盘、鼠标、屏幕的一个模式，所以当你进入headless模式，就意味着进行GUI开发，就会受限制，甚至出现异常，可以看看Button的代码：</p>
<pre><code class="java">static &#123;
    /* ensure that the necessary native libraries are loaded */
    Toolkit.loadLibraries();
    if (!GraphicsEnvironment.isHeadless()) &#123;
        initIDs();
    &#125;
&#125;
/**
     * Initialize JNI field and method IDs for fields that may be
     * accessed from C.
     */
    private static native void initIDs();
</code></pre>
<p>一上来先检查是不是headless模式再决定是否initIDs().</p>
<p>headless模式更多信息，可以看看<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/articles/javase/headless-136834.html">oracle的文档</a></p>
<h3 id="运行时监听器"><a href="#运行时监听器" class="headerlink" title="运行时监听器"></a>运行时监听器</h3><pre><code class="java">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;
    Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123;SpringApplication.class,String[].class&#125;;
    return new SpringApplicationRunListeners(logger,getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));
&#125;
</code></pre>
<p>呵！又跑去META-INF&#x2F;spring.factories 去捞类名了，这次的key是org.springframework.boot.SpringApplicationRunListener，捞出来一堆listeners实例之后，塞到SpringApplicationRunListeners里封装起来备用！对了，这次捞出来的实例只有一个，是它：</p>
<pre><code class="java">org.springframework.boot.context.event.EventPublishingRunListener
</code></pre>
<p>有个地方要注意下，这个构造的时候做了个小动作。他把SpringApplication的监听器，一股脑全注册到他自己名下了。呵！listener ！</p>
<pre><code class="java">public EventPublishingRunListener(SpringApplication application, String[] args) &#123;
        this.application = application;
        this.args = args;
        this.initialMulticaster = new SimpleApplicationEventMulticaster();
        for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;
            this.initialMulticaster.addApplicationListener(listener);
        &#125;
    &#125;
</code></pre>
<p>紧接着麻烦就通过将第一个ApplicationStartingEvent传递给这些listeners。当然不是所有的监听器都会处理这个Event，里边有复杂的判断逻辑，暂时跳过。监听器收到event之后，自然会做自己的一些准备工作。</p>
<pre><code class="java">@Override
    public void starting() &#123;
        this.initialMulticaster.multicastEvent(
                new ApplicationStartingEvent(this.application, this.args));
    &#125;
</code></pre>
<p>可以看到，这个listener的机制，可以使得启动加载环节的可拓展性非常强，可以自己酌情增减listener。因为SpringApplication暴露了添加listener的接口：</p>
<pre><code>/**
     * Add &#123;@link ApplicationListener&#125;s to be applied to the SpringApplication and
     * registered with the &#123;@link ApplicationContext&#125;.
     * @param listeners the listeners to add
     */
public void addListeners(ApplicationListener&lt;?&gt;... listeners) &#123;
    this.listeners.addAll(Arrays.asList(listeners));
&#125;
</code></pre>
<p>另外，也可以定义自己的META-INF&#x2F;spring.factories文件，在里边注册自己的listener。</p>
<h3 id="准备环境容器"><a href="#准备环境容器" class="headerlink" title="准备环境容器"></a>准备环境容器</h3><pre><code class="java">private ConfigurableEnvironment prepareEnvironment(
            SpringApplicationRunListeners listeners,
            ApplicationArguments applicationArguments) &#123;
    // Create and configure the environment
    ConfigurableEnvironment environment = getOrCreateEnvironment();
    //处理propertySource和profile
    configureEnvironment(environment, applicationArguments.getSourceArgs());
    //通知监听器
    listeners.environmentPrepared(environment);
    //将环境容器和SpringApplication绑定
    bindToSpringApplication(environment);
    if (this.webApplicationType == WebApplicationType.NONE) &#123;
        environment = new EnvironmentConverter(getClassLoader())
                .convertToStandardEnvironmentIfNecessary(environment);
    &#125;
    ConfigurationPropertySources.attach(environment);
    return environment;
&#125;
</code></pre>
<h3 id="打印Banner"><a href="#打印Banner" class="headerlink" title="打印Banner"></a>打印Banner</h3><pre><code>Banner printedBanner = printBanner(environment);
</code></pre>
<p>这个没啥，打印banner。spring支持多种banner，可以酌情使用。默认使用SpringBootBanner，打印出来，如下样式：</p>
<pre><code>  .   ____          _            __ _ _
 /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  &#39;  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.3.RELEASE)
</code></pre>
<h3 id="创建上下文"><a href="#创建上下文" class="headerlink" title="创建上下文"></a>创建上下文</h3><pre><code>context = createApplicationContext();
</code></pre>
<p>这一步创建web应用的上下文，啥叫上下文，我现在也说不清楚。以后肯定会知道的。</p>
<p>SERVLET类型的应用在这里实例化的其实是这个类：<br>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</p>
<h3 id="构建exceptionReporters"><a href="#构建exceptionReporters" class="headerlink" title="构建exceptionReporters"></a>构建exceptionReporters</h3><pre><code class="java">exceptionReporters = getSpringFactoriesInstances(
                    SpringBootExceptionReporter.class,
                    new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);
</code></pre>
<p>又又又是那个熟悉的“捞类”方法！<br>这里捞出的类是这个：<br>org.springframework.boot.diagnostics.FailureAnalyzers</p>
<p>捞出来存在了临时变量exceptionReporters里，后文里看到当启动过程抛异常的时候，会使用到这个实例。有啥用途，字面看就是报告异常，以后再深入研究。</p>
<h3 id="准备上下文"><a href="#准备上下文" class="headerlink" title="准备上下文"></a>准备上下文</h3><pre><code class="java">private void prepareContext(ConfigurableApplicationContext context,
            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
            ApplicationArguments applicationArguments, Banner printedBanner) &#123;
        context.setEnvironment(environment);
        //给上下文context预设ResourceLoader、Classloader等
        postProcessApplicationContext(context);
        //应用初始化器
        applyInitializers(context);
        // 触发Spring Boot启动过程的contextPrepared事件
        listeners.contextPrepared(context);
        if (this.logStartupInfo) &#123;
            logStartupInfo(context.getParent() == null);
            logStartupProfileInfo(context);
        &#125;

        // Add boot specific singleton beans 
        //添加两个spring boot启动过程中的特殊的单例beans  
        context.getBeanFactory().registerSingleton(&quot;springApplicationArguments&quot;,
                applicationArguments);
        if (printedBanner != null) &#123;
            context.getBeanFactory().registerSingleton(&quot;springBootBanner&quot;, printedBanner);
        &#125;

        // Load the sources
        //获得需要加载的资源
        Set&lt;Object&gt; sources = getAllSources();
        Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
        //创建BeanDefinitionLoader，并加载sources到应用上下文context
        load(context, sources.toArray(new Object[0]));
        // 触发Spring Boot启动过程的contextLoaded事件
        listeners.contextLoaded(context);
    &#125;
</code></pre>
<p>这里边东西挺多的，可以着重看下applyInitializers(context) 和 加载bean到context的这两个步骤。</p>
<h3 id="刷新上下文"><a href="#刷新上下文" class="headerlink" title="刷新上下文"></a>刷新上下文</h3><pre><code class="java">@Override
    public void refresh() throws BeansException, IllegalStateException &#123;
        synchronized (this.startupShutdownMonitor) &#123;
            // Prepare this context for refreshing.
            prepareRefresh();

            // Tell the subclass to refresh the internal bean factory.
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context.
            prepareBeanFactory(beanFactory);

            try &#123;
                // Allows post-processing of the bean factory in context subclasses.
                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                initMessageSource();

                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                onRefresh();

                // Check for listener beans and register them.
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            &#125;

            catch (BeansException ex) &#123;
                if (logger.isWarnEnabled()) &#123;
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                &#125;

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset &#39;active&#39; flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            &#125;

            finally &#123;
                // Reset common introspection caches in Spring&#39;s core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            &#125;
        &#125;
    &#125;
</code></pre>
<p>呵！好家伙，debug进去发现父类的refresh是个超级复杂的方法，刷新上下文居然做了这么多东西。本文抱着粗糙概览spring启动过程的想法，所以这里先不对这个方法展开分析。</p>
<p>需要注意下就是刷新完上下文之后，spring顺手注册了ShutdownHook,在doClose()做了很多资源释放以及触发ContextClosedEvent事件：</p>
<pre><code class="java">    @Override
    public void registerShutdownHook() &#123;
        if (this.shutdownHook == null) &#123;
            // No shutdown hook registered yet.
            this.shutdownHook = new Thread() &#123;
                @Override
                public void run() &#123;
                    synchronized (startupShutdownMonitor) &#123;
                        doClose();
                    &#125;
                &#125;
            &#125;;
            Runtime.getRuntime().addShutdownHook(this.shutdownHook);
        &#125;
    &#125;

</code></pre>
<h3 id="上下文后置处理"><a href="#上下文后置处理" class="headerlink" title="上下文后置处理"></a>上下文后置处理</h3><pre><code class="java">/**
     * Called after the context has been refreshed.
     * @param context the application context
     * @param args the application arguments
     */
    protected void afterRefresh(ConfigurableApplicationContext context,
            ApplicationArguments args) &#123;
    &#125;
</code></pre>
<p>略感意外的是这里居然是空的protected方法，网上有些教程说到在这里会调用callRunners，估计现在最新的代码已经把这个挪到了后边了吧。</p>
<h3 id="调用Runner"><a href="#调用Runner" class="headerlink" title="调用Runner"></a>调用Runner</h3><pre><code class="java">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;
        List&lt;Object&gt; runners = new ArrayList&lt;&gt;();
        runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
        runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
        AnnotationAwareOrderComparator.sort(runners);
        for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;
            if (runner instanceof ApplicationRunner) &#123;
                callRunner((ApplicationRunner) runner, args);
            &#125;
            if (runner instanceof CommandLineRunner) &#123;
                callRunner((CommandLineRunner) runner, args);
            &#125;
        &#125;
    &#125;
</code></pre>
<p>可以看到会有两种Runner，分别为ApplicationRunner 和 CommandLineRunner。凡事实现了这两个接口的Bean，都会在这个地方被调用。这两种runner没特别大的区别，都是实现run方法，只有入参不一样，一个是封装好的ApplicationArguments类型，另一个是直接的String不定长数组类型。</p>
<p>然后就结束啦，这就是RESTful Web启动的过程概览啦！</p>
<p><strong>参考资料</strong></p>
<p>[1] <a target="_blank" rel="noopener" href="http://spring.io/guides">Spring 官方教程</a><br>[2] <a target="_blank" rel="noopener" href="https://blog.csdn.net/dm_vincent/article/details/76735888">SpringBoot 启动过程源码分析</a><br>[3] <a target="_blank" rel="noopener" href="https://blog.csdn.net/dm_vincent/article/details/77151122">Spring Boot启动过程的定制化</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-RESTful%20Web%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" data-id="cltba3omo000s18r1ej2t7yag" data-title="Spring源码分析1-RESTfulWeb启动过程" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903-%E5%AF%B9Bean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%84%E7%90%86/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Spring源码分析3-对Bean循环依赖的处理
        
      </div>
    </a>
  
  
    <a href="/2018/07/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%B7%E6%96%B0%E8%BF%87%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Spring源码分析2-上下文刷新过程分析</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS%E5%8E%9F%E7%90%86/" rel="tag">CAS原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" rel="tag">代码整洁之道</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" rel="tag">垃圾回收器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" rel="tag">垃圾收集器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" rel="tag">性能分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" rel="tag">文件描述符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/" rel="tag">生产问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="tag">类加载机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" rel="tag">输入输出流</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CAS%E5%8E%9F%E7%90%86/" style="font-size: 10px;">CAS原理</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JVM/" style="font-size: 18.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/NIO/" style="font-size: 11.67px;">NIO</a> <a href="/tags/Netty/" style="font-size: 13.33px;">Netty</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Spring/" style="font-size: 16.67px;">Spring</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" style="font-size: 10px;">代码整洁之道</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" style="font-size: 13.33px;">垃圾回收器</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" style="font-size: 10px;">垃圾收集器</a> <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" style="font-size: 10px;">性能分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" style="font-size: 10px;">文件描述符</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 20px;">源码分析</a> <a href="/tags/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/" style="font-size: 13.33px;">生产问题</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">类加载机制</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a> <a href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" style="font-size: 10px;">输入输出流</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/08/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86-6-ZGC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">Java 虚拟机原理 (六) ZGC 垃圾收集器</a>
          </li>
        
          <li>
            <a href="/2021/02/09/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98-3-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%B7%E6%81%A9%E6%B3%95%E5%88%99/">生产问题(3) 应用开发过程中的海恩法则</a>
          </li>
        
          <li>
            <a href="/2021/02/07/%E6%B7%B1%E5%85%A5-MySQL-6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">深入 MySQL (六) 常见问题汇总</a>
          </li>
        
          <li>
            <a href="/2021/02/06/%E6%B7%B1%E5%85%A5-MySQL-5-%E9%94%81/">深入 MySQL (五) 锁</a>
          </li>
        
          <li>
            <a href="/2021/02/05/%E6%B7%B1%E5%85%A5-MySQL-4-%E7%B4%A2%E5%BC%95/">深入 MySQL (四) 索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 <br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>